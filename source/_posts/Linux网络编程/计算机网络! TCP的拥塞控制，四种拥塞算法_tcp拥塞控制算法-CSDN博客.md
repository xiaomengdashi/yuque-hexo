---
title: '计算机网络: TCP的拥塞控制，四种拥塞算法_tcp拥塞控制算法-CSDN博客'
date: '2025-06-26 01:03:34'
updated: '2025-06-26 02:24:40'
---
#### 目录
    - [一. 基本概念](https://blog.csdn.net/love_668/article/details/116913790#__2)
    - [二. TCP拥塞控制的四种拥塞算法](https://blog.csdn.net/love_668/article/details/116913790#_TCP_40)
        * [1️⃣ 慢开始（slow-start）](https://blog.csdn.net/love_668/article/details/116913790#1_slowstart_48)
        * [2️⃣ 拥塞避免](https://blog.csdn.net/love_668/article/details/116913790#2__49)
        * [3️⃣ 快重传](https://blog.csdn.net/love_668/article/details/116913790#3__118)
        * [4️⃣ 快恢复](https://blog.csdn.net/love_668/article/details/116913790#4__124)

### 一. 基本概念
1. 在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络性能就要被破坏，这种情况就叫做拥塞
2. 在计算机网络中的链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源
3. 若出现拥塞而不进行控制，整个网络的吞吐量将随着负荷的增大而下降

> 我们使用下图来说明拥塞控制的作用  
横坐标是输入负载，代表单位时间内输入给网络的分组数量  
纵坐标是[吞吐量](https://so.csdn.net/so/search?q=%E5%90%9E%E5%90%90%E9%87%8F&spm=1001.2101.3001.7020)，代表单位时间内从网络输出的分组数量
>

![](/images/cf0a6544de1dff73c99c5151a46b3b60.png)

> 具有理想拥塞控制的网络，在吞吐量达到饱和之前，网络吞吐量应等于输入的负载，故吞吐量曲线是45°的斜线
>

+ 但当输入负载超过某一限度时，吞吐量就不再增长而保持水平线：  
![](/images/0d909c6f410efc50fbe2c17295c039c3.png)

> 也就是吞吐量达到饱和，这就表明输入的负载中有一部分损失掉了。  
例如，输入到网络中的某些分组被某个节点丢弃了  
虽然如此，网络的吞吐量仍然维持在其所能达到的最大值。
>

```plain
😊 然而，实际的网络就很不同了，我们再来看这条吞吐量曲线
```

![](/images/6143cc014b49617b235cca9fad2149f8.png)

> 随着输入负载的增大，网络吞吐量的增长率逐渐减小，也就是在网络吞吐量还未达到饱和时，就已经有一部分的输入分组被丢弃了。
>

   


![](/images/f163e089ac14fd31809e8563f9eca1af.png)

   


+ 当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了轻度拥塞的状态。
+ 更值得注意的是，当输入负载到达某一数值时，网络的吞吐量反而随着负载的增大而减小，这是网络就进入了拥塞状态。
+ 当输入负载继续增大到某一数值时，网络的吞吐量就减小为0，此时网络就无法工作了，这就是所谓的死锁。

   


>    

>
> 因此，进行拥塞控制是非常有必要的，实际的拥塞曲线，应该尽量接近理想的拥塞控制曲线。
>
>    

>

   


### 二. TCP拥塞控制的四种拥塞算法
   


>    

>
> 下面介绍这四种拥塞控制算法的基本原理，假定如下条件：
>
>    

>

   


+ 数据是单方向传送，而另一个方向只传送确认。
+ 接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定。
+ 以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。

   


#### 1️⃣ 慢开始（slow-start）
   


#### 2️⃣ 拥塞避免
   


>    

>
> 假设下图是TCP的发送方和接收方，发送方给接收方发送TCP数据报文段，接收方收到后，给发送方发送TCP确认报文段。
>
>    

>

   


![](/images/6d7a54b34decae7f192213020e1cbfaf.png)

   


+ 发送方要维护一个叫做拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，并且动态变化。

   


>    

>
> 拥塞窗口cwnd的维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些；但只要网络出现拥塞，拥塞窗口就减少一些。  
判断出现拥塞的依据：没有按时收到应当到达的报文（即发生超时重传）。
>
>    

>

   


+ 发送方将拥塞窗口作为发送窗口swnd，即swnd=cwnd。
+ 维护一个慢开始门限ssthresh状态变量：

   


>    

>
> 当cwnd < ssthresh时，使用慢开始算法；  
当cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法；  
当cwnd = ssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法；
>
>    

>

   


+ 为了更清楚显示出拥塞控制过程,我们绘制这样一副拥塞窗口随传输轮次变化的图.  
横坐标为传输轮次,传输轮次是指发送方发送数据报文段后,接收方给发送方发回相应的确认报文段.一个轮次所经历的时间,其实就是往返时间.  
纵坐标是拥塞窗口,它会随网络拥塞程度,以及所使用的拥塞控制算法动态变化.

   


![](/images/f899f6ebb7d468aa56eac59285bb7553.png)

   


1. 在TCP双方建立逻辑连接关系时,拥塞窗口cwnd的值被设置为1,另外还需要设置慢开始门限ssthresh的初始值,本例设置为16.
2. 执行慢开始算法,发送方每收到一个对新报文段的确认时,就把拥塞窗口的值加1,然后开始下一轮的传输.
3. 当拥塞窗口值增长到慢开始门限值时,就改为执行拥塞避免算法.  
![](/images/be09461e8045983d2ee4d9520186be86.png)

> 发送方发送0号数据报文段,接收方收到后,给发送方发回对0号报文段的确认报文段.
>

![](/images/f208e4733ee3545c6d78a828b698f617.png)

> 发送方收到该确认报文段后,将拥塞窗口值加1增大到2,现在可以发送1~2号共两个数据报文段.
>

![](/images/b9a612f39029face08dcadb401babe7f.png)

> 发送方收到确认报文段后,将拥塞窗口值加2增大到4,现在可以发送3~6号共两个数据报文段.
>

多次之后  
![](/images/939f3f278a1a661642250f52e30f0631.png)

```plain
当发送方的拥塞窗口值增大到慢开始门限值之后,我们要改用拥塞避免算法.
也即是每个传输轮次结束后,拥塞窗口值只能线性加 1
而不像慢开始算法那样,每个传输轮次后,拥塞窗口值按值数规律增大.
```

> 拥塞避免算法结果如下图所示:
>

![](/images/57853cbc0f04a7b0680f87d3cfd42c5f.png)

> 假设此时部分数据报文段丢失,这必然会造成发送方对这些丢失的数据报文段进行超时重传
>

发送方以此判断网络很可能出现了拥塞,进行以下工作 :

+ 将慢开始门限值ssthresh值更新为发生拥塞时cwnd值的一半.
+ 将cwnd的值减少为1,并重新开始执行慢开始算法.

> 如下图所示 :
>

![](/images/c9c8880c9c3181397228e5181a76c2e5.png)

> 当慢开始算法执行到拥塞窗口值增大到新的慢开始门限值时,就停止使用慢开始算法,转而执行拥塞避免算法.如下图所示 :
>

![]()

> 慢开始与拥塞避免算法总结如下图所示 :
>

![]()

> 为了改进TCP的性能，又增加了快重传和快恢复算法
>

+ 有时，个别报文段会在网络中丢失，但实际上未发生网络拥塞。
+ 这将导致发送方超市重传，并误认为网络发生了拥塞；
+ 发送方把拥塞窗口cwnd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率。  
![](/images/4686c160ef62c256c763d9c7cceb8ee9.png)

#### 3️⃣ 快重传
![]()

> 快重传原理如下图所示：
>

![]()  
![]()

#### 4️⃣ 快恢复
![]()

> TCP的四种拥塞控制算法：
>

![]()

> 到这里就结束了，完结散花 😁😁😁
>

> 来自: [计算机网络: TCP的拥塞控制，四种拥塞算法_tcp拥塞控制算法-CSDN博客](https://blog.csdn.net/love_668/article/details/116913790)
>





