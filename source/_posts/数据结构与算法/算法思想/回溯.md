---
title: 回溯
date: '2025-06-06 21:23:33'
updated: '2025-06-07 01:53:24'
---
### **回溯算法（Backtracking）详解**
回溯算法是一种**通过试错来寻找所有（或部分）解的暴力搜索算法**。它通过**递归**尝试可能的解，并在发现当前路径无法得到有效解时**回退（回溯）**，尝试其他选择。

---

## **1. 回溯算法的核心特性**
### **(1) 系统性搜索**
+ 遍历所有可能的解空间（类似深度优先搜索）。
+ **适用于组合问题**（如排列、子集、棋盘类问题）。

### **(2) 状态重置（撤销选择）**
+ 每次递归后必须**恢复现场**（如撤销最后一步的选择）。

### **(3) 剪枝优化**
+ 通过约束条件提前终止无效分支的搜索（减少计算量）。

### **(4) 时间复杂度**
+ 通常为**指数级**（如 `O(n!)` 或 `O(2ⁿ)`），但剪枝可大幅优化实际运行时间。

---

## **2. 回溯算法的通用框架**
```python
def backtrack(路径, 选择列表):
    if 满足终止条件:
        保存结果（如添加到结果列表）
        return
    
    for 选择 in 选择列表:
        if 选择不合法:  # 剪枝
            continue
        做选择（如将选择加入路径）
        backtrack(路径, 新的选择列表)  # 递归
        撤销选择（如从路径中删除选择）  # 回溯
```

---

## **3. 经典问题与代码实现**
### **(1) 全排列（LeetCode 46）**
+ **问题**：给定无重复数字的数组，返回所有可能的排列。

```python
def permute(nums):
    def backtrack(path):
        if len(path) == len(nums):
            res.append(path.copy())
            return
        for num in nums:
            if num in path:  # 剪枝：已使用的数字跳过
                continue
            path.append(num)
            backtrack(path)
            path.pop()  # 回溯
    
    res = []
    backtrack([])
    return res
```

### **(2) N皇后（LeetCode 51）**
+ **问题**：在N×N棋盘上放置N个皇后，使其互不攻击。

```python
def solveNQueens(n):
    def backtrack(row):
        if row == n:
            res.append(["".join(row) for row in board])
            return
        for col in range(n):
            if not is_valid(row, col):
                continue
            board[row][col] = 'Q'
            backtrack(row + 1)
            board[row][col] = '.'  # 回溯
    
    def is_valid(row, col):
        # 检查列、左上对角线、右上对角线
        for i in range(row):
            if board[i][col] == 'Q':
                return False
            if col - (row - i) >= 0 and board[i][col - (row - i)] == 'Q':
                return False
            if col + (row - i) < n and board[i][col + (row - i)] == 'Q':
                return False
        return True
    
    board = [['.'] * n for _ in range(n)]
    res = []
    backtrack(0)
    return res
```

### **(3) 子集（LeetCode 78）**
+ **问题**：给定无重复元素的数组，返回所有可能的子集。

```python
def subsets(nums):
    def backtrack(start, path):
        res.append(path.copy())
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)  # 避免重复选择
            path.pop()
    
    res = []
    backtrack(0, [])
    return res
```

---

## **4. 回溯 vs 动态规划 vs 分治**
| **特性** | **回溯算法** | **动态规划** | **分治算法** |
| --- | --- | --- | --- |
| **解决问题类型** | 组合、排列、决策问题（如N皇后） | 最优化问题（如最短路径） | 可分解的子问题（如排序） |
| **时间复杂度** | 通常指数级（`O(2ⁿ)` 或 `O(n!)`） | 多项式时间（如 `O(n²)`） | 通常 `O(n log n)` |
| **空间复杂度** | 取决于递归深度（`O(n)`） | 需存储子问题结果 | 递归栈空间 |
| **核心操作** | 试错 + 回溯 | 状态转移 + 填表 | 分解 + 合并 |


---

## **5. 回溯算法的优化技巧**
### **(1) 剪枝（Pruning）**
+ **约束条件剪枝**：跳过不满足条件的选择（如全排列中排除已用数字）。
+ **限界剪枝**：在求最优解时，提前终止比当前解更差的分支（如旅行商问题）。

### **(2) 记忆化（Memoization）**
+ 缓存重复子问题的结果（如解决重复计算问题，但通常动态规划更优）。

### **(3) 迭代实现**
+ 用栈模拟递归调用，避免栈溢出（如DFS的迭代版本）。

---

## **6. 回溯算法的局限性**
1. **指数级复杂度**：问题规模较大时效率极低（如 `n > 20` 的全排列）。
2. **重复子问题**：若子问题重复（如斐波那契数列），动态规划更高效。
3. **难以剪枝的问题**：若无法有效剪枝，回溯可能无法在合理时间内求解。

---

## **7. 经典例题**
### **(1) 组合总和（LeetCode 39）**
+ **问题**：给定无重复元素的数组和目标值，找出所有和为目标的组合（可重复使用数字）。

```python
def combinationSum(candidates, target):
    def backtrack(start, path, remain):
        if remain == 0:
            res.append(path.copy())
            return
        for i in range(start, len(candidates)):
            if candidates[i] > remain:  # 剪枝
                continue
            path.append(candidates[i])
            backtrack(i, path, remain - candidates[i])  # 允许重复选择
            path.pop()
    
    res = []
    backtrack(0, [], target)
    return res
```

### **(2) 单词搜索（LeetCode 79）**
+ **问题**：在二维字符网格中搜索给定单词（相邻字母连接）。

```python
def exist(board, word):
    def backtrack(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]:
            return False
        tmp, board[i][j] = board[i][j], '/'  # 标记已访问
        found = (backtrack(i+1, j, k+1) or backtrack(i-1, j, k+1) or
                 backtrack(i, j+1, k+1) or backtrack(i, j-1, k+1))
        board[i][j] = tmp  # 回溯
        return found
    
    m, n = len(board), len(board[0])
    for i in range(m):
        for j in range(n):
            if backtrack(i, j, 0):
                return True
    return False
```

---

## **8. 总结**
| **关键点** | **说明** |
| --- | --- |
| **核心思想** | 递归尝试所有可能，失败时回退（“试错法”）。 |
| **适用场景** | 组合、排列、棋盘类问题（如N皇后、数独）。 |
| **优化关键** | 剪枝减少无效搜索，记忆化避免重复计算。 |
| **局限性** | 问题规模大时效率低，需谨慎使用。 |


回溯算法是解决**组合优化问题**的利器，合理剪枝后能高效求解许多NP难题！ 🔍

