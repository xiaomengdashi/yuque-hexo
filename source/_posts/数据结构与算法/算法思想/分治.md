---
title: 分治
date: '2025-06-06 21:23:17'
updated: '2025-06-07 01:50:00'
---
### **分治算法（Divide and Conquer）详解**
分治算法是一种**将问题分解为多个子问题**，递归解决子问题后**合并结果**的算法范式，是许多高效算法的基础（如快速排序、归并排序）。

---

## **1. 分治算法的核心特性**
### **(1) 分治三步骤**
1. **分解（Divide）**：将原问题划分为多个子问题（通常规模相同）。
2. **解决（Conquer）**：递归解决子问题（若子问题足够小则直接求解）。
3. **合并（Combine）**：将子问题的解合并为原问题的解。

### **(2) 适用条件**
+ **问题可分解**：能划分为相同或相似的子问题。
+ **子问题独立**：子问题之间无重叠（若有重叠则用动态规划更优）。
+ **合并效率高**：合并步骤的时间复杂度不应过高。

### **(3) 时间复杂度**
+ 由**子问题数量**、**分解规模**和**合并成本**决定，通常用**主定理**分析。

---

## **2. 分治算法的经典应用**
### **(1) 归并排序（Merge Sort）**
+ **分解**：将数组分为两半。
+ **解决**：递归排序左右子数组。
+ **合并**：合并两个有序子数组。

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

### **(2) 快速排序（Quick Sort）**
+ **分解**：选择基准（pivot），将数组分为小于和大于基准的两部分。
+ **解决**：递归排序左右部分。
+ **合并**：无需显式合并（原地排序）。

```python
def quick_sort(arr, low, high):
    if low < high:
        pivot_idx = partition(arr, low, high)
        quick_sort(arr, low, pivot_idx - 1)
        quick_sort(arr, pivot_idx + 1, high)

def partition(arr, low, high):
    pivot = arr[high]
    i = low
    for j in range(low, high):
        if arr[j] < pivot:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
    arr[i], arr[high] = arr[high], arr[i]
    return i
```

### **(3) 二分查找（Binary Search）**
+ **分解**：比较中间元素与目标值，缩小搜索范围至左半或右半。
+ **解决**：递归或迭代在子范围内查找。
+ **合并**：直接返回结果（无合并步骤）。

```python
def binary_search(arr, target, low, high):
    if low > high:
        return -1
    mid = (low + high) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        return binary_search(arr, target, low, mid - 1)
    else:
        return binary_search(arr, target, mid + 1, high)
```

### **(4) 大整数乘法（Karatsuba算法）**
+ **分解**：将大整数拆分为高位和低位。
+ **解决**：递归计算子问题。
+ **合并**：通过公式合并结果（减少乘法次数）。

```python
def karatsuba(x, y):
    if x < 10 or y < 10:
        return x * y
    n = max(len(str(x)), len(str(y)))
    m = n // 2
    a, b = divmod(x, 10**m)
    c, d = divmod(y, 10**m)
    ac = karatsuba(a, c)
    bd = karatsuba(b, d)
    ad_bc = karatsuba(a + b, c + d) - ac - bd
    return ac * 10**(2*m) + ad_bc * 10**m + bd
```

---

## **3. 分治 vs 动态规划 vs 贪心**
| **特性** | **分治算法** | **动态规划** | **贪心算法** |
| --- | --- | --- | --- |
| **子问题重叠** | 无重叠 | 有重叠 | 无重叠 |
| **最优子结构** | 不要求 | 必须 | 必须 |
| **存储中间结果** | 不存储 | 存储 | 不存储 |
| **典型问题** | 归并排序、快速排序 | 背包问题、最长公共子序列 | 区间调度、霍夫曼编码 |


---

## **4. 分治算法的局限性**
1. **递归开销大**：栈空间消耗可能导致溢出。
2. **子问题不独立时低效**：若子问题重叠（如斐波那契数列），动态规划更优。
3. **合并成本高**：若合并步骤复杂度高，可能抵消分治的优势。

---

## **5. 分治算法的优化**
### **(1) 尾递归优化**
+ 将递归转换为循环（如快速排序的迭代实现）。

### **(2) 并行化**
+ 子问题可并行求解（如MapReduce中的分治思想）。

### **(3) 阈值切换**
+ 当子问题规模较小时，切换为简单算法（如插入排序）。

---

## **6. 经典例题**
### **(1) 逆序对计数（LeetCode 315）**
+ **问题**：统计数组中逆序对的数量。
+ **分治解法**：类似归并排序，合并时统计跨子数组的逆序对。

```python
def count_inversions(arr):
    if len(arr) <= 1:
        return arr, 0
    mid = len(arr) // 2
    left, inv_left = count_inversions(arr[:mid])
    right, inv_right = count_inversions(arr[mid:])
    merged, inv_merge = merge_and_count(left, right)
    total = inv_left + inv_right + inv_merge
    return merged, total

def merge_and_count(left, right):
    result = []
    i = j = inv = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
            inv += len(left) - i
    result.extend(left[i:])
    result.extend(right[j:])
    return result, inv
```

### **(2) 最近点对问题**
+ **问题**：在平面中找到距离最近的两个点。
+ **分治解法**：
    1. 按x坐标排序，划分为左右两半。
    2. 递归求解左右半的最小距离。
    3. 检查中间带状区域是否存在更小距离。

---

## **7. 总结**
| **关键点** | **说明** |
| --- | --- |
| **核心思想** | 分而治之：分解→解决→合并。 |
| **优势** | 逻辑清晰，适合并行化，解决复杂问题（如排序、大数乘法）。 |
| **劣势** | 递归开销大，子问题重叠时效率低。 |
| **适用场景** | 问题可分解为独立子问题且合并成本低（如排序、二分查找、计算几何问题）。 |


分治算法是算法设计中的“瑞士军刀”，掌握后能高效解决许多大规模问题！ 🚀

