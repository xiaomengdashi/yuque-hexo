---
title: 贪心
date: '2025-06-06 21:23:02'
updated: '2025-06-07 01:47:11'
---
### **贪心算法（Greedy Algorithm）详解**
贪心算法是一种在**每一步选择中都采取当前状态下最优（局部最优）决策**的算法思想，希望通过局部最优的累积达到全局最优。它不像动态规划那样考虑所有可能的子问题，而是**“短视”地选择当前最佳选项**，适用于某些特定类型的问题。

---

## **1. 贪心算法的核心特性**
### **(1) 贪心选择性质（Greedy Choice Property）**
+ **局部最优 → 全局最优**：每一步的最优选择能导致最终的最优解。
+ **无后效性**：当前选择不会影响后续子问题的结构（与动态规划不同）。

### **(2) 最优子结构（Optimal Substructure）**
+ 问题的最优解包含子问题的最优解（与动态规划相同）。

### **(3) 不可回溯**
+ 一旦做出选择，就不能回退（例如，动态规划会保存中间结果，贪心算法不会）。

### **(4) 高效性**
+ 时间复杂度通常较低（如 `O(n log n)` 或 `O(n)`），但**不一定能得到全局最优解**（需问题本身满足贪心性质）。

---

## **2. 贪心算法的解题步骤**
### **(1) 问题分解**
将问题分解为多个步骤，每个步骤做一个**局部最优选择**。

### **(2) 贪心策略设计**
确定如何在每一步选择最优解（通常通过排序或优先队列实现）。

### **(3) 验证贪心正确性**
必须证明**局部最优能导致全局最优**（通常用反证法或数学归纳法）。

### **(4) 实现与优化**
用代码实现贪心策略，可能需结合数据结构（如堆、排序等）。

---

## **3. 贪心算法的经典场景**
### **(1) 区间问题**
+ **区间调度**：选择最多不重叠的区间（按结束时间排序）。

```python
def interval_scheduling(intervals):
    intervals.sort(key=lambda x: x[1])  # 按结束时间排序
    count, end = 0, -float('inf')
    for s, e in intervals:
        if s >= end:  # 不重叠
            count += 1
            end = e
    return count
```

### **(2) 背包问题（分数背包）**
+ **最大化价值**：按单位价值排序，优先拿高价值物品。

```python
def fractional_knapsack(values, weights, capacity):
    items = list(zip(values, weights))
    items.sort(key=lambda x: x[0] / x[1], reverse=True)  # 按单位价值降序
    total_value = 0
    for v, w in items:
        if capacity >= w:
            total_value += v
            capacity -= w
        else:
            total_value += v * (capacity / w)  # 拿部分
            break
    return total_value
```

### **(3) 霍夫曼编码（数据压缩）**
+ **构建最优前缀码**：每次合并频率最小的两个节点。

### **(4) 最短路径（Dijkstra算法）**
+ **非负权图的最短路径**：每次选择当前距离起点最近的节点。

---

## **4. 贪心 vs 动态规划**
| **特性** | **贪心算法** | **动态规划** |
| --- | --- | --- |
| **选择方式** | 局部最优，不可回溯 | 保存子问题结果，可回溯 |
| **时间复杂度** | 通常更低（如 `O(n log n)`） | 通常较高（如 `O(n²)`） |
| **适用问题** | 满足贪心选择性质的问题 | 具有重叠子问题和最优子结构的问题 |
| **典型问题** | 区间调度、分数背包 | 0-1背包、最长公共子序列 |


---

## **5. 贪心算法的局限性**
### **(1) 不保证全局最优**
+ 若问题不满足贪心性质，贪心算法可能得到次优解。  
**反例**：0-1背包问题（贪心无法处理，需动态规划）。

### **(2) 需严格验证正确性**
+ 必须证明贪心策略的全局最优性（例如：硬币找零问题中，硬币面值不满足贪心性质时失效）。

---

## **6. 经典例题**
### **(1) 跳跃游戏（LeetCode 55）**
+ **问题**：数组中的数字表示最大跳跃长度，判断是否能到终点。
+ **贪心策略**：维护当前能到达的最远距离。

```python
def canJump(nums):
    max_reach = 0
    for i in range(len(nums)):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + nums[i])
    return True
```

### **(2) 加油站问题（LeetCode 134）**
+ **问题**：环形路线上，加油站油量能否支持绕行一圈。
+ **贪心策略**：若总油量 ≥ 总耗油量，则必存在解。

```python
def canCompleteCircuit(gas, cost):
    total, curr, start = 0, 0, 0
    for i in range(len(gas)):
        total += gas[i] - cost[i]
        curr += gas[i] - cost[i]
        if curr < 0:
            start = i + 1
            curr = 0
    return start if total >= 0 else -1
```

---

## **7. 总结**
| **关键点** | **说明** |
| --- | --- |
| **核心思想** | 每一步选择局部最优，期望达到全局最优。 |
| **适用条件** | 问题具有贪心选择性质和最优子结构。 |
| **优势** | 高效、代码简洁。 |
| **劣势** | 不保证全局最优，需严格验证。 |
| **经典问题** | 区间调度、分数背包、最短路径、数据压缩。 |


贪心算法是解决**最优化问题**的利器，但必须谨慎验证其正确性！ 🚀

