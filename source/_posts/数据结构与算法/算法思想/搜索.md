---
title: 搜索
date: '2025-06-06 01:33:13'
updated: '2025-06-06 01:33:23'
---
### **搜索算法（Search Algorithms）详解**
搜索算法用于在数据集合（如数组、树、图等）中查找特定元素或满足条件的解。根据数据结构的不同，搜索算法可分为 **线性搜索**、**二分搜索**、**树搜索** 和 **图搜索** 等。

---

## **1. 搜索算法的核心特性**
### **(1) 确定性 vs 非确定性**
+ **确定性搜索**：每一步操作明确（如二分查找）。
+ **非确定性搜索**：可能依赖随机性或启发式规则（如模拟退火、遗传算法）。

### **(2) 完备性（Completeness）**
+ 是否能保证找到解（如果存在）。
    - **完备**：DFS（深度优先搜索）、BFS（广度优先搜索）。
    - **不完备**：随机搜索、启发式搜索（可能陷入局部最优）。

### **(3) 最优性（Optimality）**
+ 是否能找到最优解（如最短路径）。
    - **最优**：Dijkstra（权值非负）、A*（启发式正确）。
    - **非最优**：贪心算法、DFS（可能找到非最短路径）。

### **(4) 时间与空间复杂度**
+ 不同搜索算法的效率差异显著：
    - **线性搜索**：`O(n)`。
    - **二分搜索**：`O(log n)`（要求数据有序）。
    - **BFS/DFS**：`O(V + E)`（V=顶点，E=边）。

---

## **2. 搜索算法的分类与解法**
### **(1) 线性搜索（Sequential Search）**
+ **适用场景**：无序列表。
+ **实现**：逐个遍历元素，直到找到目标。

```python
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1
```

### **(2) 二分搜索（Binary Search）**
+ **适用场景**：**有序**数组。
+ **实现**：不断缩小搜索范围。

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

### **(3) 深度优先搜索（DFS）**
+ **适用场景**：树/图的路径查找、回溯问题。
+ **实现**：递归或栈实现，优先深入分支。

```python
def dfs(node, target, visited):
    if node == target:
        return True
    visited.add(node)
    for neighbor in node.neighbors:
        if neighbor not in visited:
            if dfs(neighbor, target, visited):
                return True
    return False
```

### **(4) 广度优先搜索（BFS）**
+ **适用场景**：最短路径（无权图）、层次遍历。
+ **实现**：队列实现，按层扩展。

```python
from collections import deque
def bfs(start, target):
    queue = deque([start])
    visited = set([start])
    while queue:
        node = queue.popleft()
        if node == target:
            return True
        for neighbor in node.neighbors:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    return False
```

### **(5) 启发式搜索（A*算法）**
+ **适用场景**：带权图的最短路径（如地图导航）。
+ **核心**：综合实际代价 `g(n)` 和启发式估计 `h(n)`（如曼哈顿距离）。

```python
def a_star(start, goal):
    open_set = PriorityQueue()
    open_set.put((0, start))  # (f(n), node)
    g_score = {start: 0}
    while open_set:
        _, current = open_set.get()
        if current == goal:
            return reconstruct_path(came_from, goal)
        for neighbor in current.neighbors:
            tentative_g = g_score[current] + distance(current, neighbor)
            if tentative_g < g_score.get(neighbor, float('inf')):
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g
                f_score = tentative_g + heuristic(neighbor, goal)
                open_set.put((f_score, neighbor))
    return None
```

---

## **3. 搜索算法的适用场景**
| **问题类型** | **推荐算法** | **示例** |
| --- | --- | --- |
| **无序列表查找** | 线性搜索 | 在数组中查找某个值 |
| **有序列表查找** | 二分搜索 | 在排序后的数据库中查记录 |
| **树/图的路径查找** | DFS/BFS | 迷宫求解、社交网络好友关系 |
| **最短路径（带权图）** | Dijkstra、A* | 地图导航 |
| **组合优化问题** | 回溯法（DFS + 剪枝） | 数独、八皇后问题 |
| **全局优化问题** | 模拟退火、遗传算法 | 函数最值、参数调优 |


---

## **4. 搜索算法的选择策略**
1. **数据是否有序？**
    - 有序 → **二分搜索**。
    - 无序 → **线性搜索** 或 **哈希表（O(1)）**。
2. **是否需要最短路径？**
    - 无权图 → **BFS**。
    - 带权图 → **Dijkstra/A***。
3. **解空间是否庞大？**
    - 是 → _启发式搜索（A__）_* 或 **剪枝优化（回溯法）**。
    - 否 → 暴力搜索（DFS/BFS）。
4. **是否要求最优解？**
    - 是 → 完备算法（BFS、A*）。
    - 否 → 贪心算法或随机搜索。

---

## **5. 经典例题**
### **(1) 二分查找变种（LeetCode 34）**
+ **问题**：在有序数组中查找元素的第一个和最后一个位置。
+ **解法**：二分搜索后向左右扩展。

```python
def search_range(nums, target):
    left = bisect_left(nums, target)
    right = bisect_right(nums, target) - 1
    return [left, right] if left <= right else [-1, -1]
```

### **(2) 岛屿数量（LeetCode 200）**
+ **问题**：统计矩阵中相邻1组成的岛屿数量。
+ **解法**：DFS/BFS遍历连通区域。

```python
def num_islands(grid):
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(grid, i, j)
                count += 1
    return count
```

### **(3) 单词接龙（LeetCode 127）**
+ **问题**：找到从 `beginWord` 到 `endWord` 的最短转换序列。
+ **解法**：BFS逐层扩展。

```python
def ladder_length(begin, end, word_list):
    queue = deque([(begin, 1)])
    visited = set([begin])
    while queue:
        word, steps = queue.popleft()
        if word == end:
            return steps
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                new_word = word[:i] + c + word[i+1:]
                if new_word in word_list and new_word not in visited:
                    visited.add(new_word)
                    queue.append((new_word, steps + 1))
    return 0
```

---

## **总结**
| **关键点** | **说明** |
| --- | --- |
| **线性搜索** | 简单但低效（`O(n)`），适用于无序数据。 |
| **二分搜索** | 高效（`O(log n)`），但要求数据有序。 |
| **DFS vs BFS** | DFS适合深入查找，BFS适合最短路径。 |
| **启发式搜索** | A* 结合实际代价和启发式估计，适合路径规划。 |
| **回溯法** | DFS + 剪枝，解决组合优化问题（如八皇后）。 |


搜索算法的核心在于 **高效遍历解空间**，根据问题特点选择合适的策略！ 🔍

