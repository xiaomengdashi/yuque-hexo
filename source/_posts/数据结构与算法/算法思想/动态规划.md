---
title: 动态规划
date: '2025-06-06 00:56:17'
updated: '2025-06-06 01:05:08'
---
### **动态规划（Dynamic Programming, DP）详解**
动态规划是一种用于解决 **最优化问题** 的算法思想，适用于具有 **重叠子问题** 和 **最优子结构** 特性的问题。它通过 **存储中间结果** 来避免重复计算，从而提高效率。

---

## **1. 动态规划的核心特性**
### **(1) 最优子结构（Optimal Substructure）**
+ 问题的最优解包含其子问题的最优解。
+ 例如，在最短路径问题中，`A→B→C` 的最短路径 = `A→B` 的最短路径 + `B→C` 的最短路径。

### **(2) 重叠子问题（Overlapping Subproblems）**
+ 问题可以分解为多个 **重复计算的子问题**。
+ 例如，计算斐波那契数列 `f(5) = f(4) + f(3)`，其中 `f(3)` 会被多次计算。

---

## **2. 动态规划的解法**
### **(1) 自顶向下（Top-Down）—— 记忆化递归**
+ 采用 **递归 + 备忘录（Memoization）** 存储计算结果。
+ 适用于 **子问题较少但递归深度大** 的情况。
+ **示例（斐波那契数列）**：

```python
def fib(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]
```

### **(2) 自底向上（Bottom-Up）—— 迭代法**
+ 采用 **DP 表（数组）** 递推计算，从最小子问题开始逐步求解。
+ 适用于 **子问题较多且可顺序计算** 的情况。
+ **示例（斐波那契数列）**：

```python
def fib(n):
    dp = [0] * (n + 1)
    dp[1] = dp[2] = 1
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

### **(3) 空间优化（滚动数组）**
+ 如果 `dp[i]` 仅依赖前几个状态（如 `dp[i-1]` 和 `dp[i-2]`），可以仅用 **有限变量** 存储，降低空间复杂度。
+ **示例（斐波那契数列优化版）**：

```python
def fib(n):
    if n <= 2:
        return 1
    prev, curr = 1, 1
    for _ in range(3, n + 1):
        prev, curr = curr, prev + curr
    return curr
```

---

## **3. 动态规划的适用场景**
动态规划常用于以下问题：

| **问题类型** | **经典例子** | **状态转移方程（示例）** |
| --- | --- | --- |
| **最大/最小值问题** | 最长递增子序列、最大子数组和 | `dp[i] = max(dp[i-1], nums[i] + dp[i-2])` |
| **计数问题** | 不同路径、爬楼梯 | `dp[i] = dp[i-1] + dp[i-2]` |
| **背包问题** | 0-1 背包、完全背包 | `dp[i][w] = max(val[i]+dp[i-1][w-wt[i]], dp[i-1][w])` |
| **字符串匹配** | 编辑距离、最长公共子序列 | `dp[i][j] = dp[i-1][j-1] + 1 (if s[i] == t[j])` |
| **区间 DP** | 矩阵链乘法、石子合并 | `dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost)` |


---

## **4. 动态规划的解题步骤**
1. **定义状态**  
    - 明确 `dp[i]` 或 `dp[i][j]` 代表什么（如 `dp[i]` 表示前 `i` 个元素的最优解）。
2. **确定状态转移方程**  
    - 找出 `dp[i]` 与 `dp[i-1]`、`dp[i-2]` 等的关系（如 `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`）。
3. **初始化边界条件**  
    - 设定 `dp[0]`、`dp[1]` 等初始值（如 `dp[0] = nums[0]`）。
4. **选择计算顺序**  
    - 自顶向下（递归 + 记忆化）或自底向上（迭代）。
5. **优化空间（可选）**  
    - 如果 `dp[i]` 仅依赖前几个状态，可用变量代替数组。

---

## **5. 经典例题**
### **(1) 爬楼梯（LeetCode 70）**
+ **问题**：每次可以爬 1 或 2 阶，求爬到 `n` 阶的方法数。
+ **状态转移方程**：

```python
dp[i] = dp[i-1] + dp[i-2]
```

### **(2) 打家劫舍（LeetCode 198）**
+ **问题**：不能偷相邻的房子，求最大收益。
+ **状态转移方程**：

```python
dp[i] = max(dp[i-1], dp[i-2] + nums[i])
```

### **(3) 最长递增子序列（LeetCode 300）**
+ **问题**：求数组中最长的严格递增子序列长度。
+ **状态转移方程**：

```python
dp[i] = max(dp[j] + 1 for j < i if nums[j] < nums[i])
```

---

## **总结**
| **关键点** | **说明** |
| --- | --- |
| **最优子结构** | 大问题的最优解依赖子问题的最优解。 |
| **重叠子问题** | 子问题被重复计算，适合用 DP 优化。 |
| **状态定义** | `dp[i]` 或 `dp[i][j]` 表示什么？ |
| **状态转移方程** | 如何从 `dp[i-1]`、`dp[i-2]` 等推导 `dp[i]`？ |
| **空间优化** | 如果仅依赖有限前驱状态，可用变量代替数组（如斐波那契数列优化）。 |


动态规划的核心在于 **拆解问题 + 存储中间结果**，掌握后能高效解决许多复杂问题！ 🚀

