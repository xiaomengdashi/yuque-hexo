---
title: 插入排序
date: '2025-06-06 21:37:16'
updated: '2025-06-06 21:53:04'
---
### **插入排序（Insertion Sort）详解**
**插入排序** 是一种简单直观的排序算法，适用于 **小规模数据** 或 **部分有序数据**。其核心思想是 **将未排序部分的元素逐个插入到已排序部分的正确位置**，类似于整理扑克牌。  

---

## **1. 插入排序的核心特性**
### **(1) 原地排序（In-place）**
+ 不需要额外存储空间，直接在原数组上操作。

### **(2) 稳定性（Stable）**
+ 相同元素的相对顺序不会改变（适合对复杂对象排序）。

### **(3) 时间复杂度**
+ **最坏情况**（逆序数组）：`O(n²)`（每次插入需移动所有已排序元素）。  
+ **最好情况**（已排序数组）：`O(n)`（只需比较，无需移动）。  
+ **平均情况**：`O(n²)`。

### **(4) 适用场景**
+ **小规模数据**（因常数因子小，实际效率可能优于 `O(n log n)` 算法）。  
+ **部分有序数据**（接近有序时接近线性时间）。

---

## **2. 插入排序的步骤与实现**
### **(1) 算法流程**
1. **初始化**：将数组第1个元素视为已排序序列。  
2. **遍历未排序部分**：从第2个元素开始，逐个插入到已排序部分的正确位置。  
3. **插入操作**：  
    - 将当前元素 `arr[i]` 与已排序部分的元素 **从后向前** 比较。  
    - 若 `arr[j] > key`，则将 `arr[j]` 后移一位。  
    - 直到找到 `arr[j] ≤ key` 的位置，插入 `key`。

![](/images/769f3c9bb34f6399c5a3a25b1a65f179.gif)

### **(2) 代码实现**
#### **C++ 实现**
```cpp
#include <vector>
using namespace std;

void insertionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        // 将比 key 大的元素后移
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key; // 插入到正确位置
    }
}
```

#### **Python 实现**
```python
def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        # 将比 key 大的元素后移
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key  # 插入到正确位置
```

**示例运行**：  

```python
arr = [12, 11, 13, 5, 6]
insertion_sort(arr)
print("排序后:", arr)  # 输出: [5, 6, 11, 12, 13]
```

---

## **3. 插入排序的优化**
### **(1) 二分查找优化（Binary Insertion Sort）**
+ **优化点**：用二分查找找到插入位置，减少比较次数（但仍需移动元素）。  
+ **时间复杂度**：比较次数降为 `O(n log n)`，但移动仍为 `O(n²)`。

#### **Python 实现（二分优化）**
```python
def binary_insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        # 二分查找插入位置
        left, right = 0, i - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] < key:
                left = mid + 1
            else:
                right = mid - 1
        # 移动元素并插入
        arr[left+1:i+1] = arr[left:i]
        arr[left] = key
```

### **(2) 希尔排序（Shell Sort）**
+ **优化思路**：分组插入排序，逐步缩小间隔（`gap`），最终退化为普通插入排序。  
+ **时间复杂度**：取决于 `gap` 序列，最佳可达 `O(n log² n)`。

---

## **4. 插入排序 vs 其他排序算法**
| **算法** | **时间复杂度** | **空间复杂度** | **稳定性** | **适用场景** |
| --- | --- | --- | --- | --- |
| 插入排序 | `O(n²)` | `O(1)` | ✅ | 小规模或部分有序数据 |
| 冒泡排序 | `O(n²)` | `O(1)` | ✅ | 教学用途，实际效率低 |
| 选择排序 | `O(n²)` | `O(1)` | ❌ | 交换次数少（如Flash存储） |
| 快速排序 | `O(n log n)` | `O(log n)` | ❌ | 大规模随机数据 |
| 归并排序 | `O(n log n)` | `O(n)` | ✅ | 外部排序、链表排序 |


---

## **5. 经典例题**
### **(1) 对链表进行插入排序（LeetCode 147）**
+ **问题**：链表无法随机访问，需调整指针而非交换元素。  
+ **解法**：维护已排序链表的尾指针，逐个插入。

#### **C++ 实现（链表版）**
```cpp
ListNode* insertionSortList(ListNode* head) {
    ListNode dummy(0); // 哑节点简化操作
    while (head) {
        ListNode* next = head->next;
        ListNode* prev = &dummy;
        while (prev->next && prev->next->val < head->val) {
            prev = prev->next;
        }
        head->next = prev->next;
        prev->next = head;
        head = next;
    }
    return dummy.next;
}
```

---

## **总结**
| **关键点** | **说明** |
| --- | --- |
| **核心思想** | 逐个插入到已排序部分的正确位置。 |
| **优势** | 小数据高效、稳定、原地排序。 |
| **劣势** | 大规模数据性能差（`O(n²)`）。 |
| **优化方向** | 二分查找减少比较、希尔排序分组处理。 |
| **实际应用** | 小规模数据排序、算法教学、高级排序算法的子过程（如TimSort）。 |


插入排序是理解 **排序算法基础** 的重要起点，后续可延伸学习 **希尔排序、归并排序** 等更高效的算法！ 🚀

