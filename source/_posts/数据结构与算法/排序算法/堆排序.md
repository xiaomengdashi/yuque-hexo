---
title: 堆排序
date: '2025-06-06 21:37:40'
updated: '2025-06-07 01:06:03'
---
### **堆排序（Heap Sort）详解**
堆排序是一种基于**二叉堆（Binary Heap）****数据结构的****比较类排序算法**，具有**原地排序**和**不稳定排序**的特性。它的核心思想是**将待排序序列构造成一个大顶堆（或小顶堆）**，然后**逐步取出堆顶元素**，完成排序。

---

## **1. 堆排序的核心特性**
### **(1) 时间复杂度**
+ **建堆（Heapify）**：`O(n)`（自底向上调整）
+ **排序**：每次调整堆 `O(log n)`，共 `n` 次 → `O(n log n)`
+ **总体**：`O(n log n)`（最优、最坏、平均情况一致）

### **(2) 空间复杂度**
+ **原地排序**：`O(1)`（仅需常数空间）

### **(3) 不稳定性**
+ 交换堆顶和末尾元素时可能破坏相同元素的相对顺序。

### **(4) 适用场景**
+ **大规模数据**（时间复杂度稳定在 `O(n log n)`）
+ **内存受限环境**（原地排序）
+ **优先级队列**（如定时任务调度）

---

## **2. 堆排序的步骤与实现**
### **(1) 算法流程**
1. **建堆（Heapify）**：将无序数组构造成**大顶堆**（父节点 ≥ 子节点）。
2. **排序**：
    - 交换堆顶（最大值）与末尾元素。
    - 缩小堆范围，重新调整堆结构。
    - 重复直到堆大小为1。

### **(2) 动图演示**
![](/images/ce4ba32a49313d27981c7a8aad7dc504.gif)

#### **动图解读**：
+ **黄色**：当前待调整的堆顶元素。
+ **红色**：交换堆顶与末尾元素。
+ **绿色**：已排序部分。

### **(3) 代码实现**
#### **C++ 实现**
```cpp
#include <vector>
using namespace std;

void heapify(vector<int>& arr, int n, int i) {
    int largest = i;       // 初始化最大节点为根
    int left = 2 * i + 1;  // 左子节点
    int right = 2 * i + 2; // 右子节点

    // 比较根与左右子节点
    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // 若最大值不是根，交换并递归调整
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(vector<int>& arr) {
    int n = arr.size();

    // 构建大顶堆（从最后一个非叶子节点开始）
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 逐个提取堆顶元素
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);  // 将最大值移到末尾
        heapify(arr, i, 0);    // 调整剩余堆
    }
}
```

#### **Python 实现**
```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    # 建堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # 排序
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
```

**示例运行**：

```python
arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print("排序后:", arr)  # 输出: [5, 6, 7, 11, 12, 13]
```

---

## **3. 堆排序的优化**
### **(1) 迭代代替递归**
+ 递归版本的 `heapify` 可能栈溢出，可改用循环实现：

```python
def heapify(arr, n, i):
    while True:
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        if left < n and arr[left] > arr[largest]:
            largest = left
        if right < n and arr[right] > arr[largest]:
            largest = right
        if largest == i:
            break
        arr[i], arr[largest] = arr[largest], arr[i]
        i = largest
```

### **(2) 小顶堆降序排序**
+ 修改比较逻辑即可：

```python
if left < n and arr[left] < arr[smallest]:
    smallest = left
```

---

## **4. 堆排序 vs 其他排序算法**
| **算法** | **时间复杂度** | **空间复杂度** | **稳定性** | **适用场景** |
| --- | --- | --- | --- | --- |
| 堆排序 | `O(n log n)` | `O(1)` | ❌ | 大规模数据、内存受限 |
| 快速排序 | `O(n log n)` | `O(log n)` | ❌ | 通用排序、随机数据 |
| 归并排序 | `O(n log n)` | `O(n)` | ✅ | 外部排序、稳定性要求 |
| 插入排序 | `O(n²)` | `O(1)` | ✅ | 小规模或部分有序数据 |


---

## **5. 经典例题**
### **(1) 数组中的第K个最大元素（LeetCode 215）**
+ **问题**：无需完全排序，找到第K大的元素。
+ **解法**：利用堆排序部分优化：

```python
def findKthLargest(nums, k):
    def heapify(arr, n, i):
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        if left < n and arr[left] > arr[largest]:
            largest = left
        if right < n and arr[right] > arr[largest]:
            largest = right
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)
    
    n = len(nums)
    # 构建大顶堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(nums, n, i)
    # 提取前k个元素
    for i in range(n - 1, n - k - 1, -1):
        nums[0], nums[i] = nums[i], nums[0]
        heapify(nums, i, 0)
    return nums[-k]
```

---

## **总结**
| **关键点** | **说明** |
| --- | --- |
| **核心思想** | 通过二叉堆的插入和删除操作实现排序。 |
| **优势** | 时间复杂度稳定 `O(n log n)`，原地排序。 |
| **劣势** | 不稳定，缓存不友好（跳跃访问）。 |
| **实际应用** | 优先级队列（如Python的`heapq`）、Linux内核任务调度。 |


堆排序是理解**堆数据结构**和**选择类排序**的重要基础，适合解决**Top K问题**！ 🚀

