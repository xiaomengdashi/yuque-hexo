---
title: 2小时快速掌握面试跳槽技术栈，C++算法常见50道面试题必会
date: '2025-02-11 21:57:56'
updated: '2025-02-11 23:20:54'
---
![](/images/20f5dcfc57bbef4e1e433d2118505eef.gif)

通过2个小时，我将聚焦于C+ 算法常见的50道面试题。通过深入剖析这些题目，我将系统地梳理C++算法的核心知识点和解题技巧，帮助你构建完整的知识体系，提升你的算法思维和编程能力。我相信经过这2小时的学习，你将对C++算法面试有全新的认识，为你的面试跳槽增添强大的助力。

![](/images/386bcb5230439f40c4c3d7a8529a0b2d.png)

## 1：链表反转
### **<font style="color:rgba(0, 0, 0, 0.9);">【思路分析】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">链表反转的核心思想是改变链表节点之间的指针指向，将原本的正向连接变为反向连接。具体步骤如下：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">初始化三个指针：</font>`<font style="color:rgba(0, 0, 0, 0.9);">prev</font>`<font style="color:rgba(0, 0, 0, 0.9);">初始化为</font>`<font style="color:rgba(0, 0, 0, 0.9);">nullptr</font>`<font style="color:rgba(0, 0, 0, 0.9);">，用于记录前一个节点；</font>`<font style="color:rgba(0, 0, 0, 0.9);">curr</font>`<font style="color:rgba(0, 0, 0, 0.9);">初始化为链表的头节点，用于遍历链表；</font>`<font style="color:rgba(0, 0, 0, 0.9);">next</font>`<font style="color:rgba(0, 0, 0, 0.9);">用于临时保存当前节点的下一个节点。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">遍历链表，在遍历过程中，将当前节点的</font>`<font style="color:rgba(0, 0, 0, 0.9);">next</font>`<font style="color:rgba(0, 0, 0, 0.9);">指针指向前一个节点，然后更新</font>`<font style="color:rgba(0, 0, 0, 0.9);">prev</font>`<font style="color:rgba(0, 0, 0, 0.9);">、</font>`<font style="color:rgba(0, 0, 0, 0.9);">curr</font>`<font style="color:rgba(0, 0, 0, 0.9);">和</font>`<font style="color:rgba(0, 0, 0, 0.9);">next</font>`<font style="color:rgba(0, 0, 0, 0.9);">指针。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">当</font>`<font style="color:rgba(0, 0, 0, 0.9);">curr</font>`<font style="color:rgba(0, 0, 0, 0.9);">指针遍历到链表末尾（即</font>`<font style="color:rgba(0, 0, 0, 0.9);">curr</font>`<font style="color:rgba(0, 0, 0, 0.9);">为</font>`<font style="color:rgba(0, 0, 0, 0.9);">nullptr</font>`<font style="color:rgba(0, 0, 0, 0.9);">）时，反转完成，此时</font>`<font style="color:rgba(0, 0, 0, 0.9);">prev</font>`<font style="color:rgba(0, 0, 0, 0.9);">指针指向反转后链表的头节点。</font>

```cpp
#include <iostream>


// 定义链表节点结构
struct ListNode {
int val;
ListNode* next;
ListNode(int x) : val(x), next(nullptr) {}
};


// 反转链表函数
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    while (curr != nullptr) {
        // 临时保存当前节点的下一个节点
        ListNode* next = curr->next;
        // 将当前节点的 next 指针指向前一个节点
        curr->next = prev;
        // 更新 prev 和 curr 指针
        prev = curr;
        curr = next;
    }
    // 返回反转后链表的头节点
    return prev;
}


// 辅助函数：打印链表
void printList(ListNode* head) {
    ListNode* curr = head;
    while (curr != nullptr) {
        std::cout << curr->val << " ";
        curr = curr->next;
    }
    std::cout << std::endl;
}


int main() {
    // 创建链表 1->2->3->4->5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);


    std::cout << "Original list: ";
    printList(head);


    // 反转链表
    head = reverseList(head);


    std::cout << "Reversed list: ";
    printList(head);


    // 释放链表内存
    while (head != nullptr) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">【输出结果】：</font>**

![](/images/ea2e348f74a249945ee66f653344ed90.png)

### **<font style="color:rgba(0, 0, 0, 0.9);">【递归实现】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">除了迭代方法，还可以使用递归方法实现链表反转。递归方法的核心思想是先递归地反转后续节点，然后将当前节点的</font>`<font style="color:rgba(0, 0, 0, 0.9);">next</font>`<font style="color:rgba(0, 0, 0, 0.9);">节点的</font>`<font style="color:rgba(0, 0, 0, 0.9);">next</font>`<font style="color:rgba(0, 0, 0, 0.9);">指针指向当前节点，并将当前节点的</font>`<font style="color:rgba(0, 0, 0, 0.9);">next</font>`<font style="color:rgba(0, 0, 0, 0.9);">指针置为</font>`<font style="color:rgba(0, 0, 0, 0.9);">nullptr</font>`<font style="color:rgba(0, 0, 0, 0.9);">。</font>

```cpp
#include <iostream>


// 定义链表节点结构
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


// 递归反转链表函数
ListNode* reverseListRecursive(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    // 递归反转后续节点
    ListNode* newHead = reverseListRecursive(head->next);
    // 将当前节点的 next 节点的 next 指针指向当前节点
    head->next->next = head;
    // 将当前节点的 next 指针置为 nullptr
    head->next = nullptr;
    return newHead;
}


// 辅助函数：打印链表
void printList(ListNode* head) {
    ListNode* curr = head;
    while (curr != nullptr) {
        std::cout << curr->val << " ";
        curr = curr->next;
    }
    std::cout << std::endl;
}


int main() {
    // 创建链表 1->2->3->4->5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);


    std::cout << "Original list: ";
    printList(head);


    // 递归反转链表
    head = reverseListRecursive(head);


    std::cout << "Reversed list: ";
    printList(head);


    // 释放链表内存
    while (head != nullptr) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">【输出结果】：</font>**

![](/images/84dd706fb76255d7bf1b0ae7f827f96b.png)

### <font style="color:rgba(0, 0, 0, 0.9);">【递归复杂度分析】</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);">时间复杂度：</font>****<font style="color:rgba(0, 0, 0, 0.9);">(O(n))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，其中 </font>****<font style="color:rgba(0, 0, 0, 0.9);">(n)</font>****<font style="color:rgba(0, 0, 0, 0.9);"> 是链表的长度。需要递归遍历链表一次。</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">空间复杂度：</font>****<font style="color:rgba(0, 0, 0, 0.9);">(O(n))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，主要是递归调用栈的空间开销。</font>**

## <font style="color:rgba(0, 0, 0, 0.9);">2：如何判断一个单链表是有环的。</font>
#### **<font style="color:rgba(0, 0, 0, 0.9);">方法一：【哈希表法思路分析】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">使用一个哈希表（在C++中可以使用</font>`<font style="color:rgba(0, 0, 0, 0.9);">std::unordered_set</font>`<font style="color:rgba(0, 0, 0, 0.9);">）来记录已经访问过的节点。遍历链表，对于每个节点，检查它是否已经在哈希表中。如果在，则说明链表有环；如果不在，则将该节点加入哈希表，并继续遍历下一个节点。当遍历到链表末尾（即当前节点为</font>`<font style="color:rgba(0, 0, 0, 0.9);">nullptr</font>`<font style="color:rgba(0, 0, 0, 0.9);">）时，说明链表无环。</font>

```cpp
#include <iostream>
#include <unordered_set>


// 定义链表节点结构
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


// 判断链表是否有环的函数
bool hasCycle(ListNode* head) {
    std::unordered_set<ListNode*> visited;
    ListNode* curr = head;
    while (curr != nullptr) {
        if (visited.find(curr) != visited.end()) {
            return true;
        }
        visited.insert(curr);
        curr = curr->next;
    }
    return false;
}


int main() {
    // 创建一个有环的链表示例
    ListNode* head = new ListNode(1);
    ListNode* node2 = new ListNode(2);
    ListNode* node3 = new ListNode(3);
    ListNode* node4 = new ListNode(4);
    head->next = node2;
    node2->next = node3;
    node3->next = node4;
    node4->next = node2; // 创建环


    if (hasCycle(head)) {
        std::cout << "The linked list has a cycle." << std::endl;
    }
    else {
        std::cout << "The linked list does not have a cycle." << std::endl;
    }


    // 由于有环，这里不能简单地释放内存，实际应用中需要更复杂的处理
    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">【输出结果】：</font>**

![](/images/4bf54bc8abfe94c22f777a7db6da0198.png)

#### **<font style="color:rgba(0, 0, 0, 0.9);">【复杂度分析】：</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">时间复杂度：</font>****<font style="color:rgba(0, 0, 0, 0.9);">(O(n)\)</font>****<font style="color:rgba(0, 0, 0, 0.9);">，其中 </font>****<font style="color:rgba(0, 0, 0, 0.9);">(n)</font>****<font style="color:rgba(0, 0, 0, 0.9);">是链表的长度。需要遍历链表一次，对于每个节点，在哈希表中查找和插入操作的平均时间复杂度为</font>****<font style="color:rgba(0, 0, 0, 0.9);">(O(1))</font>****<font style="color:rgba(0, 0, 0, 0.9);">。</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">空间复杂度：</font>****<font style="color:rgba(0, 0, 0, 0.9);">(O(n))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，主要用于存储哈希表中的节点，最坏情况下需要存储链表中的所有节点。</font>**

### **<font style="color:rgba(0, 0, 0, 0.9);">方法二：快慢指针法（Floyd判圈算法）思路分析</font>**
<font style="color:rgba(0, 0, 0, 0.9);">使用两个指针，一个慢指针</font>`<font style="color:rgba(0, 0, 0, 0.9);">slow</font>`<font style="color:rgba(0, 0, 0, 0.9);">每次移动一步，一个快指针</font>`<font style="color:rgba(0, 0, 0, 0.9);">fast</font>`<font style="color:rgba(0, 0, 0, 0.9);">每次移动两步。如果链表有环，那么快指针最终会追上慢指针；如果链表无环，快指针会先到达链表末尾（即</font>`<font style="color:rgba(0, 0, 0, 0.9);">fast</font>`<font style="color:rgba(0, 0, 0, 0.9);">或</font>`<font style="color:rgba(0, 0, 0, 0.9);">fast->next</font>`<font style="color:rgba(0, 0, 0, 0.9);">为</font>`<font style="color:rgba(0, 0, 0, 0.9);">nullptr</font>`<font style="color:rgba(0, 0, 0, 0.9);">）。</font>

```cpp
#include <iostream>


// 定义链表节点结构
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


// 判断链表是否有环的函数
bool hasCycle(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return false;
    }
    ListNode* slow = head;
    ListNode* fast = head->next;
    while (slow != fast) {
        if (fast == nullptr || fast->next == nullptr) {
            return false;
        }
        slow = slow->next;
        fast = fast->next->next;
    }
    return true;
}


int main() {
    // 创建一个有环的链表示例
    ListNode* head = new ListNode(1);
    ListNode* node2 = new ListNode(2);
    ListNode* node3 = new ListNode(3);
    ListNode* node4 = new ListNode(4);
    head->next = node2;
    node2->next = node3;
    node3->next = node4;
    node4->next = node2; // 创建环


    if (hasCycle(head)) {
        std::cout << "The linked list has a cycle." << std::endl;
    }
    else {
        std::cout << "The linked list does not have a cycle." << std::endl;
    }


    // 由于有环，这里不能简单地释放内存，实际应用中需要更复杂的处理
    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">【输出结果】：</font>**

![](/images/de22639b68d8efbc18b081a698f9d0b0.png)

#### **<font style="color:rgba(0, 0, 0, 0.9);">【复杂度分析】</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">时间复杂度：</font>****<font style="color:rgba(0, 0, 0, 0.9);">(O(n))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，其中(n)</font>****<font style="color:rgba(0, 0, 0, 0.9);">是链表的长度。在最坏情况下，快指针和慢指针需要遍历链表一次。</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">空间复杂度：</font>****<font style="color:rgba(0, 0, 0, 0.9);">(O(1))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，只使用了常数级的额外空间。</font>**

## <font style="color:rgba(0, 0, 0, 0.9);">3：编写算法，从10亿个浮点数当中，选出其中最大的10000个 。</font>
<font style="color:rgba(0, 0, 0, 0.9);">要从10亿个浮点数中选出最大的10000个，由于数据量巨大，无法一次性全部加载到内存中处理，因此可以采用外部排序的思想。以下是具体的实现步骤和C++代码：</font>

### **<font style="color:rgba(0, 0, 0, 0.9);">【实现步骤】</font>**
1. **<font style="color:rgba(0, 0, 0, 0.9);">数据分割：将10亿个浮点数分割成多个小文件，每个小文件包含100万个浮点数。</font>**
2. **<font style="color:rgba(0, 0, 0, 0.9);">局部排序：对每个小文件中的浮点数进行快速排序。</font>**
3. **<font style="color:rgba(0, 0, 0, 0.9);">K 路合并：使用K路合并算法将排序好的小文件合并成一个大文件。</font>**
4. **<font style="color:rgba(0, 0, 0, 0.9);">选取最大的10000个：从合并后的大文件中取出最大的10000个浮点数。</font>**

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <queue>


// 快速排序函数
void quickSort(std::vector<float>& arr, int left, int right) {
    if (left < right) {
        float pivot = arr[right];
        int i = left - 1;
        for (int j = left; j < right; j++) {
            if (arr[j] >= pivot) {
                i++;
                std::swap(arr[i], arr[j]);
            }
        }
        std::swap(arr[i + 1], arr[right]);
        int pivotIndex = i + 1;


        quickSort(arr, left, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, right);
    }
}


// 分割数据到小文件并排序
void splitAndSort(const std::string& inputFile, int chunkSize) {
    std::ifstream inFile(inputFile, std::ios::binary);
    if (!inFile) {
        std::cerr << "Failed to open input file." << std::endl;
        return;
    }


    std::vector<float> chunk(chunkSize);
    int fileIndex = 0;
    while (inFile.read(reinterpret_cast<char*>(chunk.data()), chunkSize * sizeof(float))) {
        quickSort(chunk, 0, chunkSize - 1);


        std::string outputFileName = "chunk_" + std::to_string(fileIndex) + ".bin";
        std::ofstream outFile(outputFileName, std::ios::binary);
        if (!outFile) {
            std::cerr << "Failed to open output file: " << outputFileName << std::endl;
            continue;
        }
        outFile.write(reinterpret_cast<char*>(chunk.data()), chunkSize * sizeof(float));
        outFile.close();
        fileIndex++;
    }


    // 处理最后一个不完整的块
    int remaining = inFile.gcount() / sizeof(float);
    if (remaining > 0) {
        chunk.resize(remaining);
        inFile.seekg(-remaining * sizeof(float), std::ios::cur);
        inFile.read(reinterpret_cast<char*>(chunk.data()), remaining * sizeof(float));
        quickSort(chunk, 0, remaining - 1);


        std::string outputFileName = "chunk_" + std::to_string(fileIndex) + ".bin";
        std::ofstream outFile(outputFileName, std::ios::binary);
        if (!outFile) {
            std::cerr << "Failed to open output file: " << outputFileName << std::endl;
        }
        else {
            outFile.write(reinterpret_cast<char*>(chunk.data()), remaining * sizeof(float));
            outFile.close();
        }
    }


    inFile.close();
}


// 定义一个结构体用于 K 路合并
struct Element {
    float value;
    int fileIndex;
    Element(float v, int f) : value(v), fileIndex(f) {}
    bool operator<(const Element& other) const {
        return value < other.value;
    }
};


// K 路合并
void kWayMerge(int numChunks, int topK) {
    std::vector<std::ifstream> inFiles(numChunks);
    std::priority_queue<Element> maxHeap;


    // 打开所有小文件并将每个文件的第一个元素加入最大堆
    for (int i = 0; i < numChunks; i++) {
        std::string fileName = "chunk_" + std::to_string(i) + ".bin";
        inFiles[i].open(fileName, std::ios::binary);
        if (!inFiles[i]) {
            std::cerr << "Failed to open file: " << fileName << std::endl;
            continue;
        }
        float value;
        if (inFiles[i].read(reinterpret_cast<char*>(&value), sizeof(float))) {
            maxHeap.push(Element(value, i));
        }
    }


    std::vector<float> topElements;
    while (topElements.size() < topK && !maxHeap.empty()) {
        Element top = maxHeap.top();
        maxHeap.pop();
        topElements.push_back(top.value);


        float nextValue;
        if (inFiles[top.fileIndex].read(reinterpret_cast<char*>(&nextValue), sizeof(float))) {
            maxHeap.push(Element(nextValue, top.fileIndex));
        }
    }


    // 输出最大的 10000 个元素
    for (float val : topElements) {
        std::cout << val << std::endl;
    }


    // 关闭所有文件
    for (auto& file : inFiles) {
        file.close();
    }
}


int main() {
    std::string inputFile = "input.bin";  // 假设输入文件名为 input.bin
    int chunkSize = 1000000;
    int topK = 10000;


    // 分割数据并排序
    splitAndSort(inputFile, chunkSize);


    // 计算小文件的数量
    std::ifstream inFile(inputFile, std::ios::binary);
    inFile.seekg(0, std::ios::end);
    int fileSize = inFile.tellg();
    int numChunks = (fileSize + chunkSize * sizeof(float) - 1) / (chunkSize * sizeof(float));
    inFile.close();


    // K 路合并
    kWayMerge(numChunks, topK);


    return 0;
}
```

### **<font style="color:rgba(0, 0, 0, 0.9);">【代码解释】</font>**
1. **<font style="color:rgba(0, 0, 0, 0.9);">快速排序：</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">quickSort</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">函数用于对每个小文件中的浮点数进行降序排序。</font>**
2. **<font style="color:rgba(0, 0, 0, 0.9);">数据分割和局部排序：</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">splitAndSort</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">函数将输入文件分割成多个小文件，并对每个小文件中的浮点数进行快速排序。</font>**
3. **<font style="color:rgba(0, 0, 0, 0.9);">K 路合并：</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">kWayMerge</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">函数使用最大堆来进行 K 路合并，从每个小文件中取出最大的元素，然后不断更新堆，直到取出最大的10000个元素。</font>**
4. **<font style="color:rgba(0, 0, 0, 0.9);">主函数：在</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">main</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">函数中，首先调用</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">splitAndSort</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">函数进行数据分割和局部排序，然后计算小文件的数量，最后调用</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">kWayMerge</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">函数进行 K 路合并并输出最大的10000个元素。</font>**

### <font style="color:rgba(0, 0, 0, 0.9);">复杂度分析</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);">时间复杂度：数据分割和局部排序的时间复杂度为</font>****<font style="color:rgba(0, 0, 0, 0.9);">(O(nlogm))(O(nlogm))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，其中(n)</font>****<font style="color:rgba(0, 0, 0, 0.9);"> 是总数据量，</font>****<font style="color:rgba(0, 0, 0, 0.9);">(m)</font>****<font style="color:rgba(0, 0, 0, 0.9);"> 是每个小文件的数据量。K路合并的时间复杂度为(O(klogk))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，其中(k)</font>****<font style="color:rgba(0, 0, 0, 0.9);"> 是小文件的数量。因此，总的时间复杂度为(O(nlogm + klogk))</font>****<font style="color:rgba(0, 0, 0, 0.9);">。</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">空间复杂度：主要的空间开销是每个小文件的排序和最大堆的使用，空间复杂度为(O(m + k))</font>****<font style="color:rgba(0, 0, 0, 0.9);">。</font>**

## <font style="color:rgba(0, 0, 0, 0.9);">4：最长回文子串</font>
### **<font style="color:rgba(0, 0, 0, 0.9);">方法一：【中心扩展法思路】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">回文串具有对称性，我们可以以每个字符或者每两个相邻字符为中心，向两边扩展来判断以该中心形成的回文子串的长度。遍历字符串中的每个可能的中心位置，找出最长的回文子串。</font>

```cpp
#include <iostream>
#include <string>
using namespace std;


// 从中心向两边扩展，返回以 left 和 right 为中心的最长回文子串的长度
int expandAroundCenter(const string& s, int left, int right) {
    while (left >= 0 && right < s.length() && s[left] == s[right]) {
        left--;
        right++;
    }
    return right - left - 1;
}


// 找出最长回文子串
string longestPalindrome(const string& s) {
    if (s.length() < 2) {
        return s;
    }
    int start = 0, maxLen = 0;
    for (int i = 0; i < s.length(); ++i) {
        // 以单个字符为中心扩展
        int len1 = expandAroundCenter(s, i, i);
        // 以两个相邻字符为中心扩展
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = max(len1, len2);
        if (len > maxLen) {
            maxLen = len;
            start = i - (len - 1) / 2;
        }
    }
    return s.substr(start, maxLen);
}


int main() {
    string s = "babad";
    cout << "最长回文子串是: " << longestPalindrome(s) << endl;


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">【输出结果】：</font>**

![](/images/4e4a43d1d3d9376517485d39af149446.png)

### **<font style="color:rgba(0, 0, 0, 0.9);">方法二：动态规划法思路</font>**
<font style="color:rgba(0, 0, 0, 0.9);">定义一个二维布尔数组</font>`<font style="color:rgba(0, 0, 0, 0.9);">dp[i][j]</font>`<font style="color:rgba(0, 0, 0, 0.9);">表示字符串从索引</font>`<font style="color:rgba(0, 0, 0, 0.9);">i</font>`<font style="color:rgba(0, 0, 0, 0.9);">到索引</font>`<font style="color:rgba(0, 0, 0, 0.9);">j</font>`<font style="color:rgba(0, 0, 0, 0.9);">的子串是否为回文串。状态转移方程为：</font>

![](/images/fe0f84273f03985e8d9608b5a834264f.png)

<font style="color:rgba(0, 0, 0, 0.9);">遍历所有可能的子串，找出最长的回文子串。</font>

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;


string longestPalindrome(const string& s) {
    int n = s.length();
    if (n < 2) {
        return s;
    }
    int start = 0, maxLen = 1;
    // 定义动态规划数组
    vector<vector<bool>> dp(n, vector<bool>(n, false));
    // 单个字符都是回文串
    for (int i = 0; i < n; ++i) {
        dp[i][i] = true;
    }
    // 枚举子串长度
    for (int len = 2; len <= n; ++len) {
        // 枚举子串的起始位置
        for (int i = 0; i <= n - len; ++i) {
            int j = i + len - 1;
            if (s[i] == s[j]) {
                if (len == 2) {
                    dp[i][j] = true;
                }
                else {
                    dp[i][j] = dp[i + 1][j - 1];
                }
            }
            else {
                dp[i][j] = false;
            }
            if (dp[i][j] && len > maxLen) {
                maxLen = len;
                start = i;
            }
        }
    }
    return s.substr(start, maxLen);
}


int main() {
    string s = "babad";
    cout << "最长回文子串是: " << longestPalindrome(s) << endl;
    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">【输出结果】：</font>**

![](/images/88191fbb44120cd199275fd360ad8b0c.png)

### <font style="color:rgba(0, 0, 0, 0.9);">方法三：Manacher算法思路</font>
<font style="color:rgba(0, 0, 0, 0.9);">Manacher算法是专门用于解决最长回文子串问题的高效算法，它利用了回文串的对称性，将时间复杂度优化到了</font><font style="color:rgba(0, 0, 0, 0.9);">(O(n))</font><font style="color:rgba(0, 0, 0, 0.9);">。具体做法是在原字符串的每个字符之间插入一个特殊字符（如</font>`<font style="color:rgba(0, 0, 0, 0.9);">#</font>`<font style="color:rgba(0, 0, 0, 0.9);">），将奇数长度和偶数长度的回文串统一处理，然后通过记录每个位置的回文半径来找出最长回文子串。</font>

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;


string longestPalindrome(const string& s) {
    if (s.length() < 2) {
        return s;
    }
    // 预处理字符串
    string t = "#";
    for (char c : s) {
        t += c;
        t += '#';
    }
    int n = t.length();
    vector<int> p(n, 0);
    int center = 0, right = 0;
    int maxLen = 0, start = 0;
    for (int i = 0; i < n; ++i) {
        int mirror = 2 * center - i;
        if (i < right) {
            p[i] = min(right - i, p[mirror]);
        }
        // 尝试扩展以 i 为中心的回文串
        int leftIndex = i - (1 + p[i]);
        int rightIndex = i + (1 + p[i]);
        while (leftIndex >= 0 && rightIndex < n && t[leftIndex] == t[rightIndex]) {
            p[i]++;
            leftIndex--;
            rightIndex++;
        }
        // 更新中心和右边界
        if (i + p[i] > right) {
            center = i;
            right = i + p[i];
        }
        // 更新最长回文子串的信息
        if (p[i] > maxLen) {
            maxLen = p[i];
            start = (i - maxLen) / 2;
        }
    }
    return s.substr(start, maxLen);
}


int main() {
    string s = "babad";
    cout << "最长回文子串是: " << longestPalindrome(s) << endl;
    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">【输出结果】：</font>**

![](/images/a41202cbad7d95293c5d8ada4ceadfe9.png)

#### <font style="color:rgba(0, 0, 0, 0.9);">【复杂度分析】</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);">时间复杂度：</font>****<font style="color:rgba(0, 0, 0, 0.9);">(O(n))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，其中n是字符串的长度。每个字符最多被访问两次。</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">空间复杂度：(O(n))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，主要用于存储回文半径数组。</font>**

<font style="color:rgba(0, 0, 0, 0.9);">中心扩展法和动态规划法实现相对简单，而Manacher算法时间复杂度最优，但实现较为复杂。</font>

## <font style="color:rgba(0, 0, 0, 0.9);">5：插入排序和选择排序。</font>
**<font style="color:rgba(0, 0, 0, 0.9);">插入排序基本思想：</font>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">（假定从大到小排序）依次从后面拿一个数和前面已经排好序的数进行比较，比较的过程是从已经排好序的数中最后一个数开始比较，如果比这个数，继续往前面比较，直到找到比它大的数，然后就放在它的后面，如果一直没有找到，肯定这个数已经比较到了第一个数，那就放到第一个数的前面。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">选择排序(Selection Sort)</font>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素,存放到排序序列的起始位置,然后,再从剩余未排序元素中继续寻找最小元素,然后放到排序序列末尾。以此类推,直到所有元素均排序完毕。 </font>

## <font style="color:rgba(0, 0, 0, 0.9);">6：-1,2,7,28,126请问28和126中间那个数是什么？为什么？</font>
<font style="color:rgba(0, 0, 0, 0.9);">答 、应该是4^3-1=63</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">规律是n^3-1(当n为偶数0，2，4)</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">n^3+1(当n为奇数1，3，5)</font>

## <font style="color:rgba(0, 0, 0, 0.9);">7：冒泡排序算法的时间复杂度是什么？o(n^2)。</font>
![](/images/f6dce60fc6378ce8887ac952b665b083.png)

+ **<font style="color:rgba(0, 0, 0, 0.9);">插入排序</font>**

<font style="color:rgba(0, 0, 0, 0.9);">每次将一个待排序的数据，跟前面已经有序的序列的数字一一比较找到自己合适的位置，插入到序列中，直到全部数据插入完成。</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);">希尔排序</font>**

<font style="color:rgba(0, 0, 0, 0.9);">先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对</font>**<font style="color:rgba(0, 0, 0, 0.9);">相隔若干距离</font>**<font style="color:rgba(0, 0, 0, 0.9);">的数据进行</font>**<font style="color:rgba(0, 0, 0, 0.9);">直接插入排序</font>**<font style="color:rgba(0, 0, 0, 0.9);">，因此可以形象的称希尔排序为“</font>**<font style="color:rgba(0, 0, 0, 0.9);">跳着插</font>**<font style="color:rgba(0, 0, 0, 0.9);">”</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);">冒泡排序</font>**

<font style="color:rgba(0, 0, 0, 0.9);">通过交换使相邻的两个数变成小数在前大数在后，这样每次遍历后，最大的数就“沉”到最后面了。重复N次即可以使数组有序。</font>

<font style="color:rgba(0, 0, 0, 0.9);">冒泡排序改进1：在某次遍历中如果没有数据交换，说明整个数组已经有序。因此通过设置标志位来记录此次遍历有无数据交换就可以判断是否要继续循环。</font>

<font style="color:rgba(0, 0, 0, 0.9);">冒泡排序改进2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);">快速排序</font>**

**<font style="color:rgba(0, 0, 0, 0.9);">“挖坑填数+分治法”</font>**<font style="color:rgba(0, 0, 0, 0.9);">，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j--由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。因此将数组分成二部分再分别重复上述步骤就完成了排序。</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);">选择排序</font>**

<font style="color:rgba(0, 0, 0, 0.9);">数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，直到整个数组变有序区。</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">堆排序</font>

![](/images/a6d61439b211c42df654defe9d8c9293.png)

<font style="color:rgba(0, 0, 0, 0.9);">堆的插入就是——每次插入都是将新数据放在数组最后，而从这个新数据的父结点到根结点必定是一个有序的数列，因此只要将这个新数据插入到这个有序数列中即可。</font>

<font style="color:rgba(0, 0, 0, 0.9);">堆的删除就是——堆的删除就是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点开始将一个数据在有序数列中进行“下沉”。</font>

<font style="color:rgba(0, 0, 0, 0.9);">因此，堆的插入和删除非常类似</font>**<font style="color:rgba(0, 0, 0, 0.9);">直接插入排序</font>**<font style="color:rgba(0, 0, 0, 0.9);">，只不是在</font>**<font style="color:rgba(0, 0, 0, 0.9);">二叉树</font>**<font style="color:rgba(0, 0, 0, 0.9);">上进行插入过程。所以可以将堆排序形容为“</font>**<font style="color:rgba(0, 0, 0, 0.9);">树上插</font>**<font style="color:rgba(0, 0, 0, 0.9);">”</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);">归并排序</font>**

<font style="color:rgba(0, 0, 0, 0.9);">归并排序主要分为两步：分数列（divide），每次把数列一分为二，然后分到只有两个元素的小数列；合数列（Merge），合并两个已经内部有序的子序列，直至所有数字有序。用递归可以实现。</font>

+ **<font style="color:rgba(0, 0, 0, 0.9);">基数排序（桶排序）</font>**

<font style="color:rgba(0, 0, 0, 0.9);">基数排序，第一步根据数字的个位分配到每个桶里，在桶内部排序，然后将数字再输出（串起来）；然后根据十位分桶，继续排序，再串起来。直至所有位被比较完，所有数字已经有序。</font>

![](/images/a276b0cbf61112be8ed50fadba058714.png)

## <font style="color:rgba(0, 0, 0, 0.9);">8：贪心算法</font>
<font style="color:rgba(0, 0, 0, 0.9);">贪心算法（又称贪婪算法）是指，在对</font><font style="color:rgba(0, 0, 0, 0.9);">问题求解</font><font style="color:rgba(0, 0, 0, 0.9);">时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部</font><font style="color:rgba(0, 0, 0, 0.9);">最优解</font><font style="color:rgba(0, 0, 0, 0.9);">。</font>

### **<font style="color:rgba(0, 0, 0, 0.9);">1：【活动选择问题】</font>**
#### **<font style="color:rgba(0, 0, 0, 0.9);">【问题描述】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">有n个活动，每个活动都有开始时间Si和结束时间Fi</font><font style="color:rgba(0, 0, 0, 0.9);">，要求选择一些活动，使得这些活动两两之间时间不冲突，且选择的活动数量最多。</font>

#### **<font style="color:rgba(0, 0, 0, 0.9);">【思路分析】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">按照活动的结束时间对所有活动进行排序，优先选择结束时间早的活动，这样可以为后续活动留出更多的时间。代码实现：</font>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>


// 定义活动结构体
struct Activity {
    int start;
    int end;
    Activity(int s, int e) : start(s), end(e) {}
};


// 比较函数，按活动结束时间排序
bool compare(const Activity& a1, const Activity& a2) {
    return a1.end < a2.end;
}


// 活动选择函数
std::vector<int> activitySelection(const std::vector<Activity>& activities) {
    std::vector<int> selected;
    if (activities.empty()) return selected;


    // 按结束时间排序
    std::vector<Activity> sortedActivities = activities;
    std::sort(sortedActivities.begin(), sortedActivities.end(), compare);


    // 选择第一个活动
    selected.push_back(0);
    int lastEndTime = sortedActivities[0].end;


    // 遍历剩余活动
    for (int i = 1; i < sortedActivities.size(); ++i) {
        if (sortedActivities[i].start >= lastEndTime) {
            selected.push_back(i);
            lastEndTime = sortedActivities[i].end;
        }
    }
    return selected;
}


int main() {
    std::vector<Activity> activities = { Activity(1, 4), Activity(3, 5), Activity(0, 6), Activity(5, 7),
                                        Activity(3, 9), Activity(5, 9), Activity(6, 10), Activity(8, 11),
                                        Activity(8, 12), Activity(2, 14), Activity(12, 16) };


    std::vector<int> selected = activitySelection(activities);
    std::cout << "Selected activities: ";
    for (int index : selected) {
        std::cout << index << " ";
    }
    std::cout << std::endl;


    return 0;
}
```

#### **<font style="color:rgba(0, 0, 0, 0.9);">【复杂度分析】：</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">时间复杂度：排序的时间复杂度为 </font>****<font style="color:rgba(0, 0, 0, 0.9);">(O(n log n))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，遍历活动的时间复杂度为(O(n))</font>****<font style="color:rgba(0, 0, 0, 0.9);">，因此总的时间复杂度为(O(n log n))</font>****<font style="color:rgba(0, 0, 0, 0.9);">。</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">空间复杂度：主要用于存储排序后的活动，空间复杂度为(O(n))</font>****<font style="color:rgba(0, 0, 0, 0.9);">。</font>**

### **<font style="color:rgba(0, 0, 0, 0.9);">2：【找零问题】</font>**
#### **<font style="color:rgba(0, 0, 0, 0.9);">【问题描述】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">给定不同面额的硬币</font>`<font style="color:rgba(0, 0, 0, 0.9);">coins</font>`<font style="color:rgba(0, 0, 0, 0.9);">和一个总金额</font>`<font style="color:rgba(0, 0, 0, 0.9);">amount</font>`<font style="color:rgba(0, 0, 0, 0.9);">，要求用最少数量的硬币凑出总金额</font>`<font style="color:rgba(0, 0, 0, 0.9);">amount</font>`<font style="color:rgba(0, 0, 0, 0.9);">，每种硬币的数量是无限的。</font>

#### **<font style="color:rgba(0, 0, 0, 0.9);">【思路分析】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">每次都选择面额最大的硬币，直到凑出总金额。</font>

![](/images/6adad297982dfdba2eef84f7179692e1.png)

#### **<font style="color:rgba(0, 0, 0, 0.9);">复杂度分析</font>**
**<font style="color:rgba(0, 0, 0, 0.9);">时间复杂度：排序的时间复杂度为：</font>****<font style="color:rgba(0, 0, 0, 0.9);">  
</font>**![](/images/f756e21ca689144d293c15ef5c14103a.png)**<font style="color:rgba(0, 0, 0, 0.9);">  
</font>**

<font style="color:rgba(0, 0, 0, 0.9);">其中 </font><font style="color:rgba(0, 0, 0, 0.9);">\(m\)</font><font style="color:rgba(0, 0, 0, 0.9);"> 是硬币的种类数。遍历硬币和金额的时间复杂度为</font>

![](/images/ac772671edcdea5661ce9451a56a0960.png)**<font style="color:rgba(0, 0, 0, 0.9);">  
</font>**

<font style="color:rgba(0, 0, 0, 0.9);">因此总的时间复杂度为</font>

![](/images/1867642c6cdd635a5850f534ed94c327.png)**<font style="color:rgba(0, 0, 0, 0.9);">  
</font>**

**<font style="color:rgba(0, 0, 0, 0.9);">空间复杂度</font>**<font style="color:rgba(0, 0, 0, 0.9);">：主要用于存储排序后的硬币，空间复杂度为 </font><font style="color:rgba(0, 0, 0, 0.9);">(O(m))</font><font style="color:rgba(0, 0, 0, 0.9);">。</font>

### **<font style="color:rgba(0, 0, 0, 0.9);">3：最小生成树（Kruskal算法）</font>**
#### **<font style="color:rgba(0, 0, 0, 0.9);">【问题描述】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">给定一个带权无向图，要求找出一棵连接所有顶点且边权之和最小的树。</font>

#### **<font style="color:rgba(0, 0, 0, 0.9);">【思路分析】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">将所有边按权值从小到大排序，然后依次选择边加入生成树中，只要加入该边不会形成环，直到生成树包含所有顶点。【代码实现】</font>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>


// 定义边结构体
struct Edge {
    int u, v, weight;
    Edge(int u, int v, int w) : u(u), v(v), weight(w) {}
};


// 比较函数，按边权值排序
bool compareEdges(const Edge& e1, const Edge& e2) {
    return e1.weight < e2.weight;
}


// 查找节点所在的集合
int find(std::vector<int>& parent, int i) {
    if (parent[i] == i) return i;
    return parent[i] = find(parent, parent[i]);
}


// 合并两个集合
void unionSets(std::vector<int>& parent, int x, int y) {
    int xroot = find(parent, x);
    int yroot = find(parent, y);
    parent[xroot] = yroot;
}


// Kruskal 算法
int kruskal(int V, std::vector<Edge>& edges) {
    std::sort(edges.begin(), edges.end(), compareEdges);


    std::vector<int> parent(V);
    for (int i = 0; i < V; ++i) {
        parent[i] = i;
    }


    int mstWeight = 0;
    for (Edge edge : edges) {
        int u = edge.u;
        int v = edge.v;
        int setU = find(parent, u);
        int setV = find(parent, v);


        if (setU != setV) {
            mstWeight += edge.weight;
            unionSets(parent, setU, setV);
        }
    }
    return mstWeight;
}


int main() {
    int V = 4;  // 顶点数
    std::vector<Edge> edges = { Edge(0, 1, 10), Edge(0, 2, 6), Edge(0, 3, 5), Edge(1, 3, 15), Edge(2, 3, 4) };


    int mstWeight = kruskal(V, edges);
    std::cout << "最小生成树的权值为: " << mstWeight << std::endl;


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/14d810a2cea4f452a960ea2d3d8b473c.png)

#### **<font style="color:rgba(0, 0, 0, 0.9);">复杂度分析</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">时间复杂度：排序边的时间复杂度为</font>**

![](/images/e556b744e3e4aeb84211bb5bb2be211b.png)

<font style="color:rgba(0, 0, 0, 0.9);">其中E是边的数量。并查集操作的时间复杂度接近</font>

![](/images/ab1e9e3d0f9a2af93cd0e4101660f233.png)

<font style="color:rgba(0, 0, 0, 0.9);">因此总的时间复杂度为</font>

![](/images/9c0f0eb90f4845812bdee260807cbe52.png)

**<font style="color:rgba(0, 0, 0, 0.9);">空间复杂度</font>**<font style="color:rgba(0, 0, 0, 0.9);">：主要用于存储并查集的父节点数组，空间复杂度为</font>

![](/images/be465a264a9452b61e6c00f463a44fcb.png)

<font style="color:rgba(0, 0, 0, 0.9);">其中V是顶点的数量。</font>

<font style="color:rgba(0, 0, 0, 0.9);">贪心算法在很多问题上可以高效地得到近似最优解，但并不是所有问题都适用，需要根据具体问题的性质来判断是否可以使用贪心算法。</font>

## <font style="color:rgba(0, 0, 0, 0.9);">9：动态规划</font>
<font style="color:rgba(0, 0, 0, 0.9);">给你一根长度为n的绳子，请把绳子剪成整数长度的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</font>

<font style="color:rgba(0, 0, 0, 0.9);">答案：需要取模1e9+7（1000000007），如计算初始结果为：1000000008，请返回1。</font>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>


const int MOD = 1e9 + 7;


int cuttingRope(int n) {
    if (n <= 3) return n - 1;
    // 初始化 dp 数组
    std::vector<int> dp(n + 1, 0);
    dp[2] = 1;


    for (int i = 3; i <= n; ++i) {
        for (int j = 1; j < i; ++j) {
            // 状态转移方程
            dp[i] = std::max(dp[i], std::max(j * (i - j), j * dp[i - j]));
            dp[i] %= MOD;
        }
    }
    return dp[n];
}


int main() {
    int n = 8;
    std::cout << "长度为 " << n << " 的绳子剪成若干段后的最大乘积是: " << cuttingRope(n) << std::endl;


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/858e07aed1bb21c36c94174431e51a0a.png)

## <font style="color:rgba(0, 0, 0, 0.9);">10：快速排序</font>
<font style="color:rgba(0, 0, 0, 0.9);">快速排序（Quick Sort）是一种高效的排序算法，采用分治法（Divide and Conquer）策略。它的基本思想是通过选择一个基准元素（pivot），将数组分为两部分，使得左边部分的所有元素都小于等于基准元素，右边部分的所有元素都大于等于基准元素，然后分别对左右两部分递归地进行排序。以下是使用C++实现快速排序的代码：</font>

```cpp
#include <iostream>
#include <vector>


// 分区函数，将数组分为两部分
int partition(std::vector<int>& arr, int low, int high) {
    // 选择最后一个元素作为基准元素
    int pivot = arr[high];
    int i = low - 1;


    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            // 交换 arr[i] 和 arr[j]
            std::swap(arr[i], arr[j]);
        }
    }
    // 将基准元素放到正确的位置
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}


// 快速排序函数
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        // 分区操作，获取基准元素的正确位置
        int pi = partition(arr, low, high);


        // 递归排序基准元素左边的部分
        quickSort(arr, low, pi - 1);
        // 递归排序基准元素右边的部分
        quickSort(arr, pi + 1, high);
    }
}


// 辅助函数，用于打印数组
void printArray(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}


int main() {
    std::vector<int> arr = { 10, 7, 8, 9, 1, 5 };
    int n = arr.size();


    std::cout << "Original array: ";
    printArray(arr);


    quickSort(arr, 0, n - 1);


    std::cout << "Sorted array: ";
    printArray(arr);


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/f92adcc965980620e20fa46fb8aa464f.png)

**<font style="color:rgba(0, 0, 0, 0.9);">非递归形式下的快速快速排序：</font>**

<font style="color:rgba(0, 0, 0, 0.9);">快速排序的非递归实现可以借助栈来模拟递归调用的过程。递归版本的快速排序是通过不断地递归调用自身来处理子数组，而非递归版本则使用栈来存储待处理的子数组的边界信息。以下是使用C++实现的非递归快速排序代码：</font>

```cpp
#include <iostream>
#include <vector>
#include <stack>


// 分区函数，将数组分为两部分
int partition(std::vector<int>& arr, int low, int high) {
    // 选择最后一个元素作为基准元素
    int pivot = arr[high];
    int i = low - 1;


    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            // 交换 arr[i] 和 arr[j]
            std::swap(arr[i], arr[j]);
        }
    }
    // 将基准元素放到正确的位置
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}


// 非递归快速排序函数
void quickSortNonRecursive(std::vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return;


    // 创建一个栈来存储待处理的子数组的边界
    std::stack<int> stack;
    // 初始时将整个数组的边界压入栈
    stack.push(0);
    stack.push(n - 1);


    while (!stack.empty()) {
        // 从栈中取出待处理的子数组的边界
        int high = stack.top();
        stack.pop();
        int low = stack.top();
        stack.pop();


        // 进行分区操作
        int pi = partition(arr, low, high);


        // 如果基准元素左边还有元素，将左子数组的边界压入栈
        if (pi - 1 > low) {
            stack.push(low);
            stack.push(pi - 1);
        }


        // 如果基准元素右边还有元素，将右子数组的边界压入栈
        if (pi + 1 < high) {
            stack.push(pi + 1);
            stack.push(high);
        }
    }
}


// 辅助函数，用于打印数组
void printArray(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}


int main() {
    std::vector<int> arr = { 10, 7, 8, 9, 1, 5 };
    std::cout << "Original array: ";
    printArray(arr);


    quickSortNonRecursive(arr);


    std::cout << "Sorted array: ";
    printArray(arr);


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/802fae59880948b4ba6ec942e2440570.png)

## <font style="color:rgba(0, 0, 0, 0.9);">10：冒泡排序</font>
<font style="color:rgba(0, 0, 0, 0.9);">冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。以下是使用C++实现冒泡排序的代码：</font>

```cpp
#include <iostream>
#include <vector>


// 冒泡排序函数
void bubbleSort(std::vector<int>& arr) {
    int n = arr.size();
    // 外层循环控制排序的轮数
    for (int i = 0; i < n - 1; ++i) {
        // 标记是否在本轮发生交换
        bool swapped = false;
        // 内层循环进行相邻元素的比较和交换
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                // 交换 arr[j] 和 arr[j + 1]
                std::swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        // 如果本轮没有发生交换，说明数组已经有序，提前结束排序
        if (!swapped) {
            break;
        }
    }
}


// 辅助函数，用于打印数组
void printArray(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}


int main() {
    std::vector<int> arr = { 64, 34, 25, 12, 22, 11, 90 };
    std::cout << "Original array: ";
    printArray(arr);


    bubbleSort(arr);


    std::cout << "Sorted array: ";
    printArray(arr);


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/79d96c71239ebfea4c2102244837d211.png)

## <font style="color:rgba(0, 0, 0, 0.9);">10：快速排序 </font>
<font style="color:rgba(0, 0, 0, 0.9);">快速排序（Quick Sort）是一种分治算法，它的基本思想是通过选择一个基准元素（pivot），将数组分为两部分，使得左边部分的所有元素都小于等于基准元素，右边部分的所有元素都大于等于基准元素，然后分别对左右两部分递归地进行排序。以下为你提供几种不同实现方式的快速排序C++代码。</font>

```cpp
#include <iostream>
#include <vector>


// 分区函数，将数组分为两部分
int partition(std::vector<int>& arr, int low, int high) {
    // 选择最后一个元素作为基准元素
    int pivot = arr[high];
    int i = low - 1;


    for (int j = low; j < high; ++j) {
        if (arr[j] <= pivot) {
            ++i;
            std::swap(arr[i], arr[j]);
        }
    }
    // 将基准元素放到正确的位置
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}


// 快速排序函数
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        // 分区操作，获取基准元素的正确位置
        int pi = partition(arr, low, high);


        // 递归排序基准元素左边的部分
        quickSort(arr, low, pi - 1);
        // 递归排序基准元素右边的部分
        quickSort(arr, pi + 1, high);
    }
}


// 辅助函数，用于打印数组
void printArray(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}


int main() {
    std::vector<int> arr = { 10, 7, 8, 9, 1, 5 };
    std::cout << "Original array: ";
    printArray(arr);


    quickSort(arr, 0, arr.size() - 1);


    std::cout << "Sorted array: ";
    printArray(arr);


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/4e783a72a1b43b1c4d5998bdeb5db4ba.png)

**<font style="color:rgba(0, 0, 0, 0.9);">非递归实现（使用栈模拟递归）：</font>**

```cpp
#include <iostream>
#include <vector>
#include <stack>


// 分区函数，将数组分为两部分
int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;


    for (int j = low; j < high; ++j) {
        if (arr[j] <= pivot) {
            ++i;
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}


// 非递归快速排序函数
void quickSortNonRecursive(std::vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return;


    std::stack<int> stack;
    stack.push(0);
    stack.push(n - 1);


    while (!stack.empty()) {
        int high = stack.top();
        stack.pop();
        int low = stack.top();
        stack.pop();


        int pi = partition(arr, low, high);


        if (pi - 1 > low) {
            stack.push(low);
            stack.push(pi - 1);
        }


        if (pi + 1 < high) {
            stack.push(pi + 1);
            stack.push(high);
        }
    }
}


// 辅助函数，用于打印数组
void printArray(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}


int main() {
    std::vector<int> arr = { 10, 7, 8, 9, 1, 5 };
    std::cout << "Original array: ";
    printArray(arr);


    quickSortNonRecursive(arr);


    std::cout << "Sorted array: ";
    printArray(arr);


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/3aadbf6c1c89ebdd3757296da71aeb67.png)

## <font style="color:rgba(0, 0, 0, 0.9);">10：希尔排序</font>
<font style="color:rgba(0, 0, 0, 0.9);">希尔排序（Shell Sort）是插入排序的一种改进版本，也被称为缩小增量排序。它的基本思想是将原始数据分成多个子序列来进行插入排序，随着增量逐渐减小，子序列的长度逐渐增加，整个序列会变得越来越接近有序，最后进行一次整体的插入排序，这样可以减少元素移动的次数，提高排序效率。以下是使用C++实现希尔排序的代码：</font>

```cpp
#include <iostream>
#include <vector>


// 希尔排序函数
void shellSort(std::vector<int>& arr) {
    int n = arr.size();
    // 初始增量为数组长度的一半，不断缩小增量
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 对每个子序列进行插入排序
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            int j;
            // 对当前子序列进行插入操作
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
    }
}


// 辅助函数，用于打印数组
void printArray(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}


int main() {
    std::vector<int> arr = { 12, 34, 54, 2, 3 };
    std::cout << "Original array: ";
    printArray(arr);


    shellSort(arr);


    std::cout << "Sorted array: ";
    printArray(arr);


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/73eac7f5c537527a33907c308e6a7112.png)

## <font style="color:rgba(0, 0, 0, 0.9);">11：写一个在一个字符串(n)中寻找一个子串(m)第一个位置的函数。C++ KMP算法。</font>
<font style="color:rgba(0, 0, 0, 0.9);">KMP（Knuth-Morris-Pratt）算法是一种用于字符串匹配的高效算法，其核心思想是利用已经匹配过的信息，避免在匹配过程中进行不必要的回溯，从而将时间复杂度优化到 (O(n + m))</font><font style="color:rgba(0, 0, 0, 0.9);">，其中n</font><font style="color:rgba(0, 0, 0, 0.9);">是主串的长度，</font><font style="color:rgba(0, 0, 0, 0.9);">m是子串的长度。</font>

<font style="color:rgba(0, 0, 0, 0.9);">以下是使用C++实现KMP算法来在一个字符串中寻找子串第一个位置的代码：</font>

```cpp
#include <iostream>
#include <vector>
#include <string>


// 计算部分匹配表（Next 数组）
std::vector<int> computeNext(const std::string& pattern) {
    int m = pattern.length();
    std::vector<int> next(m, 0);
    int len = 0;
    int i = 1;
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            len++;
            next[i] = len;
            i++;
        }
        else {
            if (len != 0) {
                len = next[len - 1];
            }
            else {
                next[i] = 0;
                i++;
            }
        }
    }
    return next;
}


// KMP 算法实现字符串匹配
int kmpSearch(const std::string& text, const std::string& pattern) {
    int n = text.length();
    int m = pattern.length();
    std::vector<int> next = computeNext(pattern);


    int i = 0; // 文本串的索引
    int j = 0; // 模式串的索引
    while (i < n) {
        if (pattern[j] == text[i]) {
            j++;
            i++;
        }


        if (j == m) {
            return i - j; // 找到匹配，返回第一个匹配位置的索引
        }
        else if (i < n && pattern[j] != text[i]) {
            if (j != 0) {
                j = next[j - 1];
            }
            else {
                i++;
            }
        }
    }
    return -1; // 未找到匹配
}


int main() {
    std::string text = "ABABDABACDABABCABAB";
    std::string pattern = "ABABCABAB";
    int index = kmpSearch(text, pattern);
    if (index != -1) {
        std::cout << "Pattern found at index: " << index << std::endl;
    }
    else {
        std::cout << "Pattern not found." << std::endl;
    }
    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/8e7c4cac09612dae6e1d64a715e746a1.png)

## <font style="color:rgba(0, 0, 0, 0.9);">12：如何判断一个单链表是有环的？</font>
<font style="color:rgba(0, 0, 0, 0.9);">判断一个单链表是否有环可以使用多种算法，下面主要介绍两种常见且高效的方法，分别是哈希表法和快慢指针法，并给出对应的C++代码实现。</font>

### **<font style="color:rgba(0, 0, 0, 0.9);">方法一：【哈希表法】思路</font>**
<font style="color:rgba(0, 0, 0, 0.9);">使用一个哈希集合来记录已经访问过的链表节点。遍历链表时，检查当前节点是否已经在哈希集合中，如果存在，则说明链表有环；若遍历到链表末尾（即当前节点为</font>`<font style="color:rgba(0, 0, 0, 0.9);">nullptr</font>`<font style="color:rgba(0, 0, 0, 0.9);">）都未发现重复节点，则链表无环。代码实现：</font>

```cpp
#include <iostream>
#include <unordered_set>


// 定义链表节点结构
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};


// 判断链表是否有环
bool hasCycleWithHash(ListNode* head) {
    std::unordered_set<ListNode*> visited;
    ListNode* current = head;
    while (current != nullptr) {
        if (visited.find(current) != visited.end()) {
            return true;
        }
        visited.insert(current);
        current = current->next;
    }
    return false;
}
```

## <font style="color:rgba(0, 0, 0, 0.9);">13：背包问题</font>
#### **<font style="color:rgba(0, 0, 0, 0.9);">【问题描述】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">给定一组物品，每个物品有对应的重量</font>`<font style="color:rgba(0, 0, 0, 0.9);">w[i]</font>`<font style="color:rgba(0, 0, 0, 0.9);">和价值</font>`<font style="color:rgba(0, 0, 0, 0.9);">v[i]</font>`<font style="color:rgba(0, 0, 0, 0.9);">，以及一个容量为</font>`<font style="color:rgba(0, 0, 0, 0.9);">C</font>`<font style="color:rgba(0, 0, 0, 0.9);">的背包。要求在不超过背包容量的前提下，选择一些物品放入背包，使得背包中物品的总价值最大，且每个物品只能选择放入或不放入背包（即0 - 1选择）。</font>

#### **<font style="color:rgba(0, 0, 0, 0.9);">【动态规划解法思路】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">使用二维数组</font>`<font style="color:rgba(0, 0, 0, 0.9);">dp[i][j]</font>`<font style="color:rgba(0, 0, 0, 0.9);">来表示前</font>`<font style="color:rgba(0, 0, 0, 0.9);">i</font>`<font style="color:rgba(0, 0, 0, 0.9);">个物品放入容量为</font>`<font style="color:rgba(0, 0, 0, 0.9);">j</font>`<font style="color:rgba(0, 0, 0, 0.9);">的背包中所能获得的最大价值。状态转移方程为：</font>

![](/images/a30953af4c598780c258e505c4c53cb3.png)

<font style="color:rgba(0, 0, 0, 0.9);">C++代码实现：</font>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>


// 0 - 1 背包问题函数
int knapsack01(const std::vector<int>& weights, const std::vector<int>& values, int capacity) {
    int n = weights.size();
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(capacity + 1, 0));


    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= capacity; ++j) {
            if (j < weights[i - 1]) {
                dp[i][j] = dp[i - 1][j];
            }
            else {
                dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);
            }
        }
    }


    return dp[n][capacity];
}


int main() {
    std::vector<int> weights = { 2, 3, 4, 5 };
    std::vector<int> values = { 3, 4, 5, 6 };
    int capacity = 8;


    int result = knapsack01(weights, values, capacity);
    std::cout << "最大价值为: " << result << std::endl;


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/d38af1bca4ee89d47e893a655614c434.png)

**<font style="color:rgba(0, 0, 0, 0.9);">以下是使用DFS的C++实现：</font>**

<font style="color:rgba(0, 0, 0, 0.9);">深度优先搜索（Depth-First Search，DFS）是一种用于遍历或搜索树或图的算法。该算法沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。</font>

<font style="color:rgba(0, 0, 0, 0.9);">下面分别给出在树和图上实现DFS的C++代码示例。树的DFS实现【问题描述】，给定一棵二叉树，对其进行深度优先搜索（前序遍历）。</font>

```cpp
#include <iostream>


// 定义二叉树节点结构
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// 前序遍历的 DFS 函数
void dfsTree(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    // 访问当前节点
    std::cout << root->val << " ";
    // 递归访问左子树
    dfsTree(root->left);
    // 递归访问右子树
    dfsTree(root->right);
}


int main() {
    // 构建一个简单的二叉树
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);


    std::cout << "树的前序 DFS 遍历结果: ";
    dfsTree(root);
    std::cout << std::endl;


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/4d7ab698ca6f1df0e0e1558091f179c9.png)

## <font style="color:rgba(0, 0, 0, 0.9);">15：动态规划</font>
<font style="color:rgba(0, 0, 0, 0.9);">动态规划就是先取得当前情况下的最优解  成立就在原来的基础上加一 不成立就原地变成1。</font>

### **<font style="color:rgba(0, 0, 0, 0.9);">【最长递增子序列问题描述】</font>**
<font style="color:rgba(0, 0, 0, 0.9);">给定一个无序的整数数组</font>`<font style="color:rgba(0, 0, 0, 0.9);">nums</font>`<font style="color:rgba(0, 0, 0, 0.9);">，找到其中最长递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，</font>`<font style="color:rgba(0, 0, 0, 0.9);">[3,6,2,7]</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 是数组 </font>`<font style="color:rgba(0, 0, 0, 0.9);">[0,3,1,6,2,2,7]</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 的一个子序列。</font>

### **<font style="color:rgba(0, 0, 0, 0.9);">【动态规划思路】</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">定义状态：设</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">dp[i]</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">表示以第</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">i</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">个元素结尾的最长递增子序列的长度。</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">初始化：每个元素自身可以构成一个长度为1的递增子序列，所以初始时</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">dp[i] = 1</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">，其中</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">i</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">从0到 </font>**`**<font style="color:rgba(0, 0, 0, 0.9);">nums.size() - 1</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">。</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">状态转移方程：对于每个</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">i</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">，遍历</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">0</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">到</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">i - 1</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">的所有 </font>**`**<font style="color:rgba(0, 0, 0, 0.9);">j</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">，如果</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">nums[j] < nums[i]</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">，说明可以将第</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">i</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">个元素接在以第</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">j</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">个元素结尾的递增子序列后面，此时更新</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">dp[i] = max(dp[i], dp[j] + 1)</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">。</font>**
+ **<font style="color:rgba(0, 0, 0, 0.9);">最终结果：最长递增子序列的长度为</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">dp</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">数组中的最大值。</font>**

### **<font style="color:rgba(0, 0, 0, 0.9);">C++代码实现：</font>**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>


// 计算最长递增子序列的长度
int lengthOfLIS(const std::vector<int>& nums) {
    if (nums.empty()) return 0;
    int n = nums.size();
    // 初始化 dp 数组，每个元素初始值为 1
    std::vector<int> dp(n, 1);


    // 动态规划过程
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[j] < nums[i]) {
                // 更新 dp[i]
                dp[i] = std::max(dp[i], dp[j] + 1);
            }
        }
    }


    // 找出 dp 数组中的最大值
    return *std::max_element(dp.begin(), dp.end());
}


int main() {
    std::vector<int> nums = { 10, 9, 2, 5, 3, 7, 101, 18 };
    int result = lengthOfLIS(nums);
    std::cout << "最长递增子序列的长度是: " << result << std::endl;


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/5fabceca025376d8e459b33db473053e.png)

## <font style="color:rgba(0, 0, 0, 0.9);">16：树的两种遍历得到树并按照第三种遍历方式输出。</font>
<font style="color:rgba(0, 0, 0, 0.9);">在树的遍历中，常见的遍历方式有前序遍历（根 - 左 - 右）、中序遍历（左 - 根 - 右）和后序遍历（左 - 右 - 根）。已知其中两种遍历序列，通常可以唯一确定一棵树（前提是包含中序遍历序列，因为中序遍历可以区分左右子树），然后按照第三种遍历方式输出。下面以已知前序遍历和中序遍历序列，构建树并进行后序遍历输出为例，给出C++代码实现。</font>

### **<font style="color:rgba(0, 0, 0, 0.9);">思路分析</font>**
1. **<font style="color:rgba(0, 0, 0, 0.9);">前序遍历特点：前序遍历的第一个元素是根节点。</font>**
2. **<font style="color:rgba(0, 0, 0, 0.9);">中序遍历特点：根节点将中序遍历序列分为左子树和右子树两部分。</font>**
3. **<font style="color:rgba(0, 0, 0, 0.9);">构建树的过程：</font>**
    - <font style="color:rgba(0, 0, 0, 0.9);">从前序遍历序列中取出第一个元素作为根节点。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">在中序遍历序列中找到该根节点的位置，以此将中序遍历序列分为左子树和右子树。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">根据左子树和右子树的长度，从前序遍历序列中划分出左子树和右子树的前序遍历序列。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">递归地构建左子树和右子树。</font>
4. **<font style="color:rgba(0, 0, 0, 0.9);">后序遍历输出：按照左 - 右 - 根的顺序遍历构建好的树。</font>**

### **<font style="color:rgba(0, 0, 0, 0.9);">代码实现：</font>**
```cpp
#include <iostream>
#include <vector>


// 定义树节点结构
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// 根据前序和中序遍历构建树
TreeNode* buildTree(const std::vector<int>& preorder, const std::vector<int>& inorder) {
    if (preorder.empty() || inorder.empty()) {
        return nullptr;
    }
    // 前序遍历的第一个元素是根节点
    int rootVal = preorder[0];
    TreeNode* root = new TreeNode(rootVal);


    // 在中序遍历中找到根节点的位置
    int rootIndexInorder = 0;
    for (int i = 0; i < inorder.size(); ++i) {
        if (inorder[i] == rootVal) {
            rootIndexInorder = i;
            break;
        }
    }


    // 划分左子树和右子树的前序和中序遍历序列
    std::vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + rootIndexInorder + 1);
    std::vector<int> leftInorder(inorder.begin(), inorder.begin() + rootIndexInorder);
    std::vector<int> rightPreorder(preorder.begin() + rootIndexInorder + 1, preorder.end());
    std::vector<int> rightInorder(inorder.begin() + rootIndexInorder + 1, inorder.end());


    // 递归构建左子树和右子树
    root->left = buildTree(leftPreorder, leftInorder);
    root->right = buildTree(rightPreorder, rightInorder);


    return root;
}


// 后序遍历树
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    std::cout << root->val << " ";
}


// 释放树的内存
void freeTree(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    freeTree(root->left);
    freeTree(root->right);
    delete root;
}


int main() {
    std::vector<int> preorder = { 3, 9, 20, 15, 7 };
    std::vector<int> inorder = { 9, 3, 15, 20, 7 };


    // 构建树
    TreeNode* root = buildTree(preorder, inorder);


    // 后序遍历输出
    std::cout << "后序遍历结果: ";
    postorderTraversal(root);
    std::cout << std::endl;


    // 释放树的内存
    freeTree(root);


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/2824e196a3a2505205ac9c06d0c40d83.png)

## <font style="color:rgba(0, 0, 0, 0.9);">17：unordered_map计统计string中出现的char的次数。</font>
<font style="color:rgba(0, 0, 0, 0.9);">在C++中，可以使用</font>`<font style="color:rgba(0, 0, 0, 0.9);">std::unordered_map</font>`<font style="color:rgba(0, 0, 0, 0.9);">来统计字符串中每个字符出现的次数。</font>`<font style="color:rgba(0, 0, 0, 0.9);">std::unordered_map</font>`<font style="color:rgba(0, 0, 0, 0.9);">是一种关联容器，它存储键值对，并且可以通过键快速访问对应的值，非常适合用于字符计数这种场景。以下是具体的代码实现：</font>

```cpp
#include <iostream>
#include <string>
#include <unordered_map>


// 统计字符串中字符出现的次数
std::unordered_map<char, int> countChars(const std::string& str) {
    std::unordered_map<char, int> charCount;
    // 遍历字符串中的每个字符
    for (char c : str) {
        // 如果字符已经在 map 中，对应的值加 1
        // 如果不在 map 中，会默认插入该字符，值初始化为 0 后再加 1
        ++charCount[c];
    }
    return charCount;
}


int main() {
    std::string input = "hello, world!";
    // 调用函数统计字符出现次数
    std::unordered_map<char, int> result = countChars(input);


    // 输出统计结果
    for (const auto& pair : result) {
        std::cout << "字符 '" << pair.first << "' 出现了 " << pair.second << " 次。" << std::endl;
    }


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/15dc05aceb0a9c035a02e6278e690c25.png)

## <font style="color:rgba(0, 0, 0, 0.9);">18：string中的最长的不重复子串（双指针+unordered_map）。</font>
### **<font style="color:rgba(0, 0, 0, 0.9);">算法思路</font>**
1. **<font style="color:rgba(0, 0, 0, 0.9);">双指针：使用两个指针</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">left</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">和</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">right</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">来维护一个滑动窗口，</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">right</font>**`**<font style="color:rgba(0, 0, 0, 0.9);"> 指针不断向右移动，用于扩展窗口；</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">left</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">指针根据情况移动，用于收缩窗口，以保证窗口内的子串不包含重复字符。</font>**
2. `**<font style="color:rgba(0, 0, 0, 0.9);">unordered_map：使用</font>**``**<font style="color:rgba(0, 0, 0, 0.9);">unordered_map<char, int></font>**`**<font style="color:rgba(0, 0, 0, 0.9);">来记录每个字符最后一次出现的位置。当</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">right</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">指针遇到一个已经在 </font>**`**<font style="color:rgba(0, 0, 0, 0.9);">unordered_map</font>**`**<font style="color:rgba(0, 0, 0, 0.9);"> 中存在的字符时，需要检查该字符上次出现的位置是否在当前窗口内。如果在窗口内，需要移动</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">left</font>**`**<font style="color:rgba(0, 0, 0, 0.9);">指针到该字符上次出现位置的下一个位置，以保证窗口内的子串不包含重复字符。</font>**
3. **<font style="color:rgba(0, 0, 0, 0.9);">记录最长子串长度：在移动指针的过程中，不断更新最长不重复子串的长度。</font>**

### **<font style="color:rgba(0, 0, 0, 0.9);">C++ 代码实现：</font>**
```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <algorithm>


// 找出字符串中最长的不重复子串的长度
int lengthOfLongestSubstring(const std::string& s) {
    int n = s.length();
    // 记录字符最后一次出现的位置
    std::unordered_map<char, int> charIndexMap;
    int left = 0;
    int maxLength = 0;


    for (int right = 0; right < n; ++right) {
        char currentChar = s[right];
        // 如果当前字符已经在 map 中，并且其上次出现的位置在当前窗口内
        if (charIndexMap.find(currentChar) != charIndexMap.end() && charIndexMap[currentChar] >= left) {
            // 移动 left 指针到该字符上次出现位置的下一个位置
            left = charIndexMap[currentChar] + 1;
        }
        // 更新当前字符的最后出现位置
        charIndexMap[currentChar] = right;
        // 计算当前窗口的长度
        int currentLength = right - left + 1;
        // 更新最长不重复子串的长度
        maxLength = std::max(maxLength, currentLength);
    }


    return maxLength;
}


int main() {
    std::string s = "abcabcbb";
    int result = lengthOfLongestSubstring(s);
    std::cout << "最长不重复子串的长度是: " << result << std::endl;


    return 0;
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">输出结果：</font>**

![](/images/a2d514ff0157618613e0551ca94d09d6.png)

## <font style="color:rgba(0, 0, 0, 0.9);">19：树的问题：简单树的深度</font>
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```

**<font style="color:rgba(0, 0, 0, 0.9);">二叉树的镜像</font>**

```cpp
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(!root) return root;
        help(root);
        return root;
    }
    void help(TreeNode* root){
        if(root==nullptr) return;
        //TreeNode* temp=root->left;
        //root->left = root->right;
        //root->right = temp;
        swap(root->left,root->right);
        help(root->left);
        help(root->right);
    }
};
```

**<font style="color:rgba(0, 0, 0, 0.9);">本质上就是swap和迭代 直到nullptr然后return。</font>**

## <font style="color:rgba(0, 0, 0, 0.9);">20：最长连续序列</font>
<font style="color:rgba(0, 0, 0, 0.9);">简单的方法：这个是计算得到数组中的最长的连续递增子序列的最大长度  递增的间隔是1 。</font>

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        // 对整个数组进行排序
        sort(nums.begin(), nums.end());//一个sort就是 nlogn;n 
        // 去重操作 unique把不重复的排序 但是长度不变
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        // ans是最终答案，cnt用于记录临时答案 
        int ans = 0, cnt = 0;
        for (int i = 0; i < nums.size(); i++){
            if (i > 0 && nums[i] == nums[i-1] + 1)
                cnt++;
            else
                cnt = 0;
            ans = max(ans, cnt+1);
        }
        return ans;
    }
};
//unique()函数是将重复的元素折叠缩编，使成唯一
```

<font style="color:rgba(0, 0, 0, 0.9);">使用count，返回的是被查找元素的个数。如果有，返回1；否则，返回0。注意，map中不存在相同元素，所以返回值只能是1或0。</font>

<font style="color:rgba(0, 0, 0, 0.9);">使用find，返回的是被查找元素的位置，没有则返回map.end()。</font>

<font style="color:rgba(0, 0, 0, 0.9);">最长的连续字符子串  区别在于else后面的结果直接就是0不需要再比较大小。</font>

## <font style="color:rgba(0, 0, 0, 0.9);">21：最长公共子序列</font>
```cpp
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int n = A.size(), m = B.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if(A[i-1]==B[j-1]) dp[i][j] = dp[i-1][j-1]+1;
                else
                     dp[i][j] = 0;
//连续的就是0 不连续就是max(dp[i-1][j],dp[i][j-1])
                ans = max(ans, dp[i][j]);
            }
        }
        return ans;
    }
};
```

## <font style="color:rgba(0, 0, 0, 0.9);">22：有效的括号。</font>
```cpp
class Solution {
public:
    bool isValid(string s) {
        if(s=="") return true;
        for(int i=1;i<s.size();){
            if(s[i]-s[i-1]==1||s[i]-s[i-1]==2){
                s.erase(i-1,2);
                if(s=="") return true;
                if(i>1)  i--;
            }
            else
                i++;
        }
        if(s=="") return true;
        return false;


    }
};
```

## <font style="color:rgba(0, 0, 0, 0.9);">23：三数之和。</font>
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
            // 错误去重方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;


                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }


        }
        return result;
    }
};
```

## <font style="color:rgba(0, 0, 0, 0.9);">24：分糖果。</font>
```cpp
#include <iostream>
#include <vector>
int candy(const std::vector<int>& ratings) {
    int n = ratings.size();
    std::vector<int> candies(n, 1);
    // 从左到右遍历
    for (int i = 1; i < n; ++i) {
        if (ratings[i] > ratings[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }
    // 从右到左遍历
    for (int i = n - 2; i >= 0; --i) {
        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {
            candies[i] = candies[i + 1] + 1;
        }
    }
    // 计算糖果总数
    int totalCandies = 0;
    for (int candy : candies) {
        totalCandies += candy;
    }
    return totalCandies;
}
int main() {
    std::vector<int> ratings = {1, 2, 2};
    int result = candy(ratings);
    std::cout << "最少需要的糖果数: " << result << std::endl;
    return 0;
}
```

## <font style="color:rgba(0, 0, 0, 0.9);">25：不用加号计算加法。</font>
```cpp
#include <iostream>
// 不使用加号实现加法的函数
int add(int a, int b) {
    while (b != 0) {
        // 计算进位
        int carry = (unsigned int)(a & b) << 1;
        // 不进位相加
        a = a ^ b;
        // 更新 b 为进位结果
        b = carry;
    }
    return a;
}
int main() {
    int num1 = 5;
    int num2 = 3;
    int result = add(num1, num2);
    std::cout << num1 << " + " << num2 << " = " << result << std::endl;
    return 0;
}
```

## <font style="color:rgba(0, 0, 0, 0.9);">26：链表求和。</font>
```cpp
class Solution
{
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)
    {
        ListNode *head = new ListNode(-1), *p1 = l1, *p2 = l2, *p = head;//用带头节点的可以少一点初始的特判
        int sum = 0, carr = 0;
        while (p1 || p2 || carr) //如果改用&&则while结束还要多一些特判
        {
            sum = 0;//当前两位数字和
            if(p1)
            {
                sum += (p1->val);
                p1 = p1->next;
            }
            if(p2)
            {
                sum += (p2->val);
                p2 = p2->next;
            }
            sum += carr; //加上上一位的进位
            ListNode *t = new ListNode(sum % 10); //得到当前位数字
            carr = sum / 10; //得到当前位对下一位的进位
            p->next = t;//当前位连接上去
            p = p->next;//游标指针更新
        }
        return head->next;
    }
};
```

**<font style="color:rgba(0, 0, 0, 0.9);">完整版本的 需要输出的计算求和。</font>**

```cpp
#include<iostream>
#include<vector>
using namespace std;


struct ListNode {
    int val;
    ListNode* next;
    ListNode(int a) { val = a; next = NULL; }
};


ListNode* help(ListNode* head1, ListNode* head2);


int main() {
    vector<int> v1{ 7,1,6 };
    vector<int> v2{ 5,9,6 };
    ListNode* head1 = new ListNode(0); 
    ListNode* head11 = head1;
    ListNode* head2 = new ListNode(0);
    ListNode* head22 = head2;
    for (int i = 0; i < v1.size(); i++) {
        head1->next = new ListNode(v1[i]);
        head1 = head1->next;
    }
    for (int i = 0; i < v2.size(); i++) {
        head2->next = new ListNode(v2[i]);
        head2 = head2->next;
    }
    //函数的使用
    ListNode* ans = help(head11->next,head22->next);
    while (ans) {
        cout << ans->val;
        ans = ans->next;
    }


    return 0;
}
ListNode* help(ListNode* head1, ListNode* head2) {
    ListNode* ans = new ListNode(0);
    ListNode* ans1 = ans;
    int flag = 0;
    int sum;
    while (head1 || head2 || flag) {
        sum = 0;
        if (head1) {
            sum += head1->val;
            head1 = head1->next;
        }
        if (head2) {
            sum += head2->val;
            head2 = head2->next;
        }
        ans->next = new ListNode((sum+flag) % 10);//结点连接
        flag = sum / 10;




        ans = ans->next;
    }
    return ans1->next;
}
```

## <font style="color:rgba(0, 0, 0, 0.9);">27：计算数组中出现次数最多的那个数。</font>
```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int,int> m;
        for(auto s:nums){
            m[s]++;
        }
        int ans=0;
        map<int,int> m1;


        for(auto s:m){
            m1[s.second]=s.first;
        }
        for(auto s:m1)
           ans=s.second;


        return ans;


    }
};
```

## <font style="color:rgba(0, 0, 0, 0.9);">28：1234组成没有重复数字的三位数。</font>
```cpp
int main() {
    for (int i = 1; i < 5; i++) {
        for (int j = 1; j < 5; j++) {
            for (int k = 1; k < 5; k++) {
                if (i != j && j != k && i != k)
                {
                    printf("%d%d%d", i, j, k);
                    cout << endl;
                }
            }
        }
    }
    return 0;
}
```

## <font style="color:rgba(0, 0, 0, 0.9);">29：合并两个有序链表。</font>
```cpp
#include<iostream>
#include<vector>
using namespace std;


struct ListNode {
    int val;
    ListNode* next;
    ListNode(int a) { val = a; next = NULL; }
};
ListNode* plus_node(ListNode* head1, ListNode* head2);
ListNode* hebing(ListNode* head1, ListNode* head2);


int main() {
    vector<int> v1{ 2,7,9 };
    vector<int> v2{ 5,6,10,12};
    ListNode* head1 = new ListNode(0); 
    ListNode* head11 = head1;
    ListNode* head2 = new ListNode(0);
    ListNode* head22 = head2;
    for (int i = 0; i < v1.size(); i++) {
        head1->next = new ListNode(v1[i]);
        head1 = head1->next;
    }
    for (int i = 0; i < v2.size(); i++) {
        head2->next = new ListNode(v2[i]);
        head2 = head2->next;
    }
    //函数的使用
    //ListNode* ans = plus_node(head11->next,head22->next);
    ListNode* ans = hebing(head11->next, head22->next);
    while (ans) {
        cout << ans->val;
        ans = ans->next;
    }
    return 0;
}


ListNode* hebing(ListNode* head1, ListNode* head2) {
    ListNode* ans = new ListNode(0);
    ListNode* ans1 = ans;
    while (head1 && head2) {
        if (head2->val > head1->val) {
            ans1->next = head1;
            head1 = head1->next;
            ans1 = ans1->next;
        }
        else {
            ans1->next = head2;
            head2 = head2->next;
            ans1 = ans1->next;
        }


    }
    if (!head1) ans1->next = head2;
    if (!head2) ans1->next = head1;//这两行很重要
    return ans->next;
}


ListNode* plus_node(ListNode* head1, ListNode* head2) {
    ListNode* ans = new ListNode(0);
    ListNode* ans1 = ans;
    int flag = 0;
    int sum;
    while (head1 || head2 || flag) {
        sum = 0;
        if (head1) {
            sum += head1->val;
            head1 = head1->next;
        }
        if (head2) {
            sum += head2->val;
            head2 = head2->next;
        }
        ans->next = new ListNode((sum+flag) % 10);//结点连接
        flag = sum / 10;




        ans = ans->next;
    }
    return ans1->next;
}
```

## <font style="color:rgba(0, 0, 0, 0.9);">30：字典找单词。</font>
```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0; i < board.size(); i++){
            for(int j = 0; j < board[0].size(); j++){
                if(backtrack(board, word, 0, i , j)){ // 从二维表格的每一个格子出发
                    return true;
                }
            }
        }
        return false;
    }
private:
    bool backtrack(vector<vector<char>>& board, string& word, int wordIndex, int x, int y){
        if( board[x][y] != word[wordIndex]){ // 当前位的字母不相等，此路不通
            return false;
        }
        if(word.size() - 1  == wordIndex){ // 最后一个字母也相等, 返回成功
            return true;
        }
        char tmp = board[x][y]; 
        board[x][y] = 0; // 避免该位重复使用
        wordIndex++;
        if((x > 0 && backtrack(board, word, wordIndex, x - 1, y)) // 往左走
        || (y > 0 && backtrack(board, word, wordIndex, x,   - 1)) // 往上走
        || (x < board.size() - 1 && backtrack(board, word, wordIndex, x + 1, y)) // 往右走
        || (y < board[0].size() - 1 && backtrack(board, word, wordIndex, x, y + 1))){ // 往下走
            return  true; // 其中一条能走通，就算成功
        }
        board[x][y] = tmp; // 如果都不通，则回溯上一状态
        return false;
    }
};
```

## <font style="color:rgba(0, 0, 0, 0.9);">31：单词的压缩编码。</font>
```cpp
class Solution {
public:
    int minimumLengthEncoding(vector<string>& words) {
        set<string> set_1(words.begin(),words.end());
        for(auto s:set_1){
            for(int i=1;i<s.size();i++)
            set_1.erase(s.substr(i,s.size()-i));//这个是为了删除一个string的尾部开始 最后一个 最后两个 最后三个
            //换一种写法  set_1.erase(s.substr(i)  只有一个参数代表是从后面开始选取string的一部分
        }
        int ans=0;
        for(auto s:set_1){
            ans+=(s.size()+1);
        }
        return ans;


    }
};
```

<font style="color:rgba(0, 0, 0, 0.9);">把string存入set然后对每一个元素的子元素字符串（后面开始） 删除  最后的结果就是set的每一个元素的长度+1的和string。substr(i)  从i开始到最后的字符串就是答案。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">31：</font>****<font style="color:rgba(0, 0, 0, 0.9);">丑数。</font>**

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> v(1,1);
        int temp;
        int ans=1;
        int i=1;


        int p2=0,p3=0,p5=0;
        while(i++<n){
            temp = min(min(v[p2]*2,v[p3]*3),v[p5]*5);
            v.push_back(temp);
            if(temp==v[p2]*2) p2++;
            if(temp==v[p3]*3) p3++;
            if(temp==v[p5]*5) p5++;
        }
        return v[v.size()-1];
    }
};
```

**<font style="color:rgba(0, 0, 0, 0.9);">这个是简单版本 容易理解的版本  这是把所有的数据全部写入进去 然后取其中的一个值  定义abc时 需要longlong因为虽然是int但是乘积的时候会超出 所以需要用long long。</font>**

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> v;
        for (long long a=1;a<=INT_MAX;a=a*2)
            for (long long b=a;b<=INT_MAX;b=b*3)
                for (long long c=b;c<=INT_MAX;c=c*5)
                    v.push_back(c);
        sort(v.begin(),v.end());
        return v[n-1];
    }
};
```

**<font style="color:rgba(0, 0, 0, 0.9);">32：</font>****<font style="color:rgba(0, 0, 0, 0.9);">删除链表的倒数第k个结点在这个基础上还可以输出倒数某一个节点的值。</font>**

```cpp
#include<iostream>
#include<vector>
#include<set>
#include<limits.h>
using namespace std;


struct ListNode {
    int val;
    ListNode* next;
    ListNode(int a) { val = a; next = NULL; }
};
ListNode* creat(vector<int> v);
ListNode* delete_K(ListNode* node, int k);
int main() {
    vector<int> v{ 0,1,2,3,4,5,6 };
    ListNode* ans =creat(v);


    ListNode* temp = delete_K(ans, 3);






    while (temp) {
        cout << temp->val;
        temp = temp->next;
    }
    return 0;
}


ListNode* creat(vector<int> v) {
    ListNode* ans = new ListNode(-1);
    ListNode* ans1 = ans;
    for (int i = 0; i < v.size(); i++) {
        ans->next = new ListNode(v[i]);
        ans = ans->next;
    }
    return ans1->next;
}


ListNode* delete_K(ListNode* node, int k) {
    ListNode* head1 = node;
    ListNode* head2 = node;
    ListNode* temp = head2;
    for (int i = 0; i < k; i++) {
        head1 = head1->next;
    }
    while (head1->next) {
        head1 = head1->next;
        head2 = head2->next;
    }
    head2->next = head2->next->next;//略过去一个节点
    return temp;
}
```

## <font style="color:rgba(0, 0, 0, 0.9);">33：旋转链表。</font>
**<font style="color:rgba(0, 0, 0, 0.9);">首先是k%len得到一个数，因为len就是一个循环，然后对于余数，可以在链表的len-余数的位置使得node->next = nullptr;</font>**

## <font style="color:rgba(0, 0, 0, 0.9);">34：两个字符串的最长公共子串----动态规划。</font>
**<font style="color:rgba(0, 0, 0, 0.9);">这是个动态规划的题动态规划的关键在于构建一个二维数组。</font>**

```cpp
#include<iostream>
#include<vector>
#include<set>
#include<limits.h>
#include<algorithm>
using namespace std;
int help(string s1, string s2);
int main() {
    string s1="abcdg";
    string s2="defg";


    int ans = help(s1, s2);
    cout << ans;
    return 0;
}


int help(string s1, string s2) {
    int l1 = s1.size();
    int l2 = s2.size();
    vector<vector<int>> v(l1 + 1, vector<int>(l2 + 1, 0));
    for (int i = 1; i < l1 + 1; i++) {
        for (int j = 1; j < l2 + 1; j++) {
            if (s2[j-1] == s1[i-1])
                v[i][j] = v[i - 1][j - 1] + 1;
            else
                v[i][j] = max(v[i - 1][j], v[i][j - 1]);
        }
    }
    return v[l1][l2];
}
```

**<font style="color:rgba(0, 0, 0, 0.9);">背包问题：行成m+1 n+1矩阵 外围为0然后对于每一个i比较第i行的数据  然后j变化  第一个出现的数  可以认为是  在i个物体的情况下，权重w为j的情况下，即前i个物体中，最大值放在了第一个，然后依次类推，放两个放3个放i个物体。</font>**

## <font style="color:rgba(0, 0, 0, 0.9);">35：顺时针打印矩阵。</font>
```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& v) {
        vector<int> v1;
        if(v.empty()) return v1;//这个很重要
        int left=0,up=0,right=v[0].size()-1,low=v.size()-1;
        while(left<=right&&low>=up){
            for(int i=left;i<=right;i++)
                v1.push_back(v[up][i]);
            up++;
            if(up>low) break;
            for(int i=up;i<=low;i++)
                v1.push_back(v[i][right]);
            right--;
            if(left>right) break;
            for(int i=right;i>=left;i--)
                v1.push_back(v[low][i]);
            low--;
            if(up>low) break;
            for(int i=low;i>=up;i--)
                v1.push_back(v[i][left]);
            left++;
            if(left>right) break;
        }
        return v1;
    }
};
```

## <font style="color:rgba(0, 0, 0, 0.9);">36：最长回文子串。</font>
<font style="color:rgba(0, 0, 0, 0.9);">外部循环每个数然后再选取一定的字符子串判断是否符合要求，但是问题是 字串的的确定判断很费事；</font>

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int len=s.size();
        if(len==0||len==1)
            return s;
        int start=0;//记录回文子串起始位置
        int end=0;//记录回文子串终止位置
        int mlen=0;//记录最大回文子串的长度
        for(int i=0;i<len;i++)
        {
            int len1=help(s,i,i);//一个元素为中心
            int len2=help(s,i,i+1);//两个元素为中心
            mlen=max(max(len1,len2),mlen);
            if(mlen>end-start+1) 
            //上一步的长度 每计算出 一个 mlen就要计算在该mlen的情况下数据的起始和结束
            {
                start=i-(mlen-1)/2;
                end=i+mlen/2;
            }
        }
        return s.substr(start,mlen);  //substr 从start开始 长度为 mlen
        //该函数的意思是获取从start开始长度为mlen长度的字符串
    }


    int help(string s,int left,int right)
    //计算以left和right为中心的回文串长度
    {
        int L=left;   //一个元素的话 必然会执行循环 i<len-1 i=0 的话 len =-1
        int R=right;  //两个元素为中心的话 如果不相等 结果就是 0 R-L-1=0
        while(L>=0 && R<s.length() && s[R]==s[L])
        {
            L--;
            R++;
        }
        return R-L-1;
    }
};
```

## <font style="color:rgba(0, 0, 0, 0.9);">37：行成3的最大倍数：1363。</font>
```cpp
/*
 贪心，先降序sort,然后统计出%3结果为0,1,2的数
 把所有数都放进一个mulitiset里面维护
 0的无脑放
 %3为1和为2的，可能两两组合，也可能3个为1或者3个为2的放在一起


 当出现1个1，3个2时，或者3个1，1个2时，不进行配对。因为不配对得到的结果更长


*/
class Solution {
public:
    string largestMultipleOfThree(vector<int>& digits) {
        if (digits.empty()) return "";
        sort(digits.rbegin(),digits.rend());
        vector<int>zero,one,two;
        for (const auto &digit:digits){
            int val = digit % 3;
            if (val==0){
                zero.push_back(digit);
            }else if (val==1){
                one.push_back(digit);
            }else if (val==2){
                two.push_back(digit);
            }
        }
        // printf(" %d %d %d\n",zero.size(),one.size(),two.size());
        multiset<int,std::greater<int>>all(zero.begin(),zero.end());


        int head = 0;
        while (head<one.size()&&head<two.size()){
            int r1 = one.size()-head;
            int r2 = two.size()-head;
            if (r1%3==0&&r2%3==1) break;
            if (r2%3==0&&r1%3==1) break;
            all.insert(one[head]);
            all.insert(two[head]);
            head++;
        }
        while (head+2<one.size()||head+2<two.size()){
            if (head+2<one.size()){
                all.insert(one[head]);
                all.insert(one[head+1]);
                all.insert(one[head+2]);
            }
            if (head+2<two.size()){
                all.insert(two[head]);
                all.insert(two[head+1]);
                all.insert(two[head+2]);
            }
            head+=3;


        }
        // 只有全是0时，才会出现前缀0，不然总可以把0放后面
        // printf("all.size():%d\n",all.size());
        if (all.size()>0&&*all.begin()==0) return "0";
        string res;
        // transform(all.begin(),all.end(),back_inserter(res),[](int x){return x+'0';});
        for (const auto & x: all){
            // cout<<"miao"<<endl;
            res = res + char(x+'0');
        }
        return res;
    }
};
```

## <font style="color:rgba(0, 0, 0, 0.9);">38：全排列。</font>
```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ans;
        if(nums.size()<=1) {ans.push_back(nums);return  ans;}
        help(ans,nums,0,nums.size()-1);
        return ans;
     }
    void help(vector<vector<int>>&ans,vector<int>&nums,int left,int right){
         if(left==right) {ans.push_back(nums);return;}
         for(int i=left;i<=right;i++){
             swap(nums[i],nums[left]);
             help(ans,nums,left+1,right);
             swap(nums[i],nums[left]);
         }
     }
};
```

## <font style="color:rgba(0, 0, 0, 0.9);">39：链表的排序。</font>
```cpp
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
//先判断 是否是单节点或者空
        if(!head||!head->next) return head;
        ListNode* ans=new ListNode(-1);
        ans->next=head;
        ListNode* cur = head;
        ListNode* node= head->next;
        while(node){
            ListNode* temp=ans;
            if(cur->val>node->val){
                while(temp->next->val<node->val)
                    temp=temp->next;


                cur->next=node->next;
                node->next=temp->next;
                temp->next=node;
//////////////////////////////////////////////要动起来
                node=cur->next;  //这里主要是用来移动的
            }
            else{
                cur=cur->next;
                node=node->next;
            }


        }
    return ans->next;
    }
};
```

## <font style="color:rgba(0, 0, 0, 0.9);">40：动态规划最长的路径。</font>
```cpp
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {


        vector<vector<int>> ans(grid.size(),vector<int>(grid[0].size(),0));
        ans[0][0]=grid[0][0];
        for(int i=1;i<grid.size();i++)
            ans[i][0]=grid[i][0]+ans[i-1][0];


        for(int i=1;i<grid[0].size();i++)
            ans[0][i]=grid[0][i]+ans[0][i-1];


        for(int i=1;i<grid.size();i++){
            for(int j=1;j<grid[0].size();j++){
                ans[i][j]=max(ans[i-1][j],ans[i][j-1])+grid[i][j];
            }
        }


        return ans[grid.size()-1][grid[0].size()-1];


    }
};
```

**<font style="color:rgba(0, 0, 0, 0.9);">从矩阵的一个点到另一个点，构建一个矩阵和原先的大小一致，关键在于   ans[i][j] = max(ans[i-1][j],ans[i][j-1]) + grid[i][j]</font>**

<font style="color:rgba(0, 0, 0, 0.9);">string str2=str1.substr(4,3); // 利用substr函数将第一个字符串从第str[4]的位置拷3个,大概是 "are"这个样子</font>

<font style="color:rgba(0, 0, 0, 0.9);">s.erase(0,2)删除前两个元素。</font>

<font style="color:rgba(0, 0, 0, 0.9);">set<int> set(v.begin(), v.end());  把vector中的数据放入set</font>

<font style="color:rgba(0, 0, 0, 0.9);">string.substr(N) 截取x[N]到结尾。</font>

```cpp
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(!root) return root;
        help(root);
        return root;
    }
    void help(TreeNode* root){
        if(root==nullptr) return;
        //TreeNode* temp=root->left;
        //root->left = root->right;
        //root->right = temp;
        swap(root->left,root->right);
        help(root->left);
        help(root->right);
    }
};
```

  


> 来自: [2小时快速掌握面试跳槽技术栈，C++算法常见50道面试题必会](https://mp.weixin.qq.com/s/rog1zwm7EbLfO6l5dELdwg)
>

