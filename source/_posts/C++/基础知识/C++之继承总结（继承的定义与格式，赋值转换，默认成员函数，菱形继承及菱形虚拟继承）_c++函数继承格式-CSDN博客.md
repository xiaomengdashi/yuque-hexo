---
title: C++之继承总结（继承的定义与格式，赋值转换，默认成员函数，菱形继承及菱形虚拟继承）_c++函数继承格式-CSDN博客
date: '2024-12-31 01:13:23'
updated: '2024-12-31 13:15:27'
---
#### C++中继承相关知识
+ [1.继承的概念及定义](https://blog.csdn.net/qq_45657288/article/details/116140635#1_1)
    - [1.1继承的概念](https://blog.csdn.net/qq_45657288/article/details/116140635#11_2)
    - [1.2继承的定义](https://blog.csdn.net/qq_45657288/article/details/116140635#12_47)
        * [1.2.1定义格式](https://blog.csdn.net/qq_45657288/article/details/116140635#121_48)
        * [1.2.2继承关系和访问限定符](https://blog.csdn.net/qq_45657288/article/details/116140635#122_53)
        * [1.2.3继承基类成员访问方式的变化](https://blog.csdn.net/qq_45657288/article/details/116140635#123_56)
+ [2.基类和派生类对象赋值转换（只存在于公有继承当中）](https://blog.csdn.net/qq_45657288/article/details/116140635#2_67)
+ [3.继承中的作用域](https://blog.csdn.net/qq_45657288/article/details/116140635#3_86)
+ [4.派生类的默认成员函数](https://blog.csdn.net/qq_45657288/article/details/116140635#4_95)
+ [5.继承与友元](https://blog.csdn.net/qq_45657288/article/details/116140635#5_116)
+ [6.继承与静态成员](https://blog.csdn.net/qq_45657288/article/details/116140635#6_121)
+ [7.菱形继承及菱形虚拟继承](https://blog.csdn.net/qq_45657288/article/details/116140635#7_125)
    - [7.1单继承与多继承](https://blog.csdn.net/qq_45657288/article/details/116140635#71_126)
    - [7.2菱形继承存在的问题及解决方案](https://blog.csdn.net/qq_45657288/article/details/116140635#72_133)
    - [7.3虚拟继承](https://blog.csdn.net/qq_45657288/article/details/116140635#73_137)
    - [7.4虚拟继承解决数据冗余和二义性的原理](https://blog.csdn.net/qq_45657288/article/details/116140635#74_140)
+ [8.总结与反思](https://blog.csdn.net/qq_45657288/article/details/116140635#8_152)
    - [8.1继承和组合](https://blog.csdn.net/qq_45657288/article/details/116140635#81_156)

## 1.继承的概念及定义
### 1.1继承的概念
+ **继承**(inheritance)机制是面向对象程序设计**使代码可以复用**的最重要的手段，它允许程序员在**保持原有类特性的基础上进行扩展**，增加功能，这样产生新的类，称派生类。继承**呈现了面向对象程序设计的层次结构**，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是**类设计层次的复用**
+ 我们看以下代码的运行结果

```cpp
#include<iostream>
#include<string>
using namespace std;

class Person
{
public:
void Print()
{
    cout << "name:" << _name << endl;
    cout << "age:" << _age << endl;
}
protected:
string _name = "peter"; // 姓名
int _age = 18; // 年龄
};
class Student : public Person
{
protected:
int _stuid; // 学号
};
class Teacher : public Person
{
protected:
int _jobid; // 工号
};
int main()
{
    Student s;
    Teacher t;
    s.Print();
    t.Print();
    return 0;
}
```

+ 运行结果：  
![](/images/63042621260f6077324aca810da723af.png)
+ 总结：继承后父类的Person的成员（成员函数+成员变量）都会变成子类的一部分。这里体现出了Student和Teacher复用了Person的成员。

### 1.2继承的定义
#### 1.2.1定义格式
![](/images/46b8fd32aacee9d2ded55af94c03fc00.png)  
![](/images/3dca21e29f5a426afbc788312491af7b.png)

#### 1.2.2继承关系和访问限定符
![](/images/9b4d20388c8ebc3988092630524552e5.png)

#### 1.2.3继承[基类](https://so.csdn.net/so/search?q=%E5%9F%BA%E7%B1%BB&spm=1001.2101.3001.7020)成员访问方式的变化
![](/images/ec789d34a949c31779952d2856209d6a.png)

1. **总结：**
2. 基类private成员在派生类中无论以什么方式继承都是**不可见**的。`这里的不可见是指基类的私有成员还是 被继承到了派生类对象中，但是语法上限制生类对象不管在类里面还是类外面都不能去访问它`
3. 基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能 访问，就定义为`protected`。**可以看出保护成员限定符是因继承才出现的**
4. 实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 = `Min(成员在基类的访问限定符，继承方式)`，`public` > `protected` > `privat`
5. 使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，**不过最好显示的写出继承方式**
6. **在实际运用中一般使用都是public继承，几乎很少用protetced/private继承，也不提倡使用protetced/private继承**，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强

## 2.基类和派生类对象赋值转换（只存在于公有继承当中）
+ **派生类对象**可以赋值给**基类的对象** / **基类的指针** / **基类的引用**。这里有个形象的说法叫`切片`或者`切割`。寓意把派生类中父类那部分切来赋值过去
+ 基类对象不能赋值给派生类对象
+ 基类的指针可以通过强制类型转换赋值给派生类的指针。但是必须是基类的指针是指向派生类对象时才是安全的。这里基类如果是多态类型，可以使用 **RTTI(Run-Time Type Information)** 的`dynamic_cast`来进行识别后进行安全转换。  
![](/images/1900b56eccc3702f3e5b207fbb8d3410.png)
+ **我们对应看三个例子：**
+ **赋值给基类的对象**

![](/images/81c66b27fabf9e3aaa8f52bc58dac09e.png)

+ **赋值给基类的引用**  
![](/images/c63f571a3205a9b84464329d9ec5fd48.png)
+ **赋值给基类的指针**  
![](/images/52c534000d39bca1ba378f3744d0cdf3.png)
+ **总结**：  
![](/images/c2a7d05178e487faff1b65e9d3b71c1b.png)

## 3.继承中的[作用域](https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020)
+ 在继承体系中`基类`和`派生类`都有`独立的作用域`（可以定义同名的变量）
+ 子类和父类中`有同名成员`，**子类成员将屏蔽父类对同名成员的直接访问**，这种情况叫隐藏，也叫`重定义`
+ 需要注意的是如果是[成员函数](https://so.csdn.net/so/search?q=%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)的隐藏，只需要函数名相同就构成隐藏
+ 注意在实际中在继承体系里面最好不要定义同名的成员
+ **举例：**  
![](/images/17d0d0d3cc729864c66907902fe507d4.png)

## 4.派生类的默认成员函数
+ **6个默认成员函数**，“默认”的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类中，**这几个成员函数是如何生成的呢？**
+ `Ⅰ`.**构造函数**：派生类的构造函数**必须调用基类的构造函数初始化基类的那一部分成员**。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用  
![](/images/bd48406e5b6a3a5feda245ca162d3783.png)
+ `Ⅱ`.**拷贝构造**： 派生类的拷贝构造函数必**须调用基类的拷贝构造完成基类的拷贝初始化**  
![](/images/c443ed8febacb9348259f6935538204c.png)
+ `Ⅲ`. **赋值运算符重载**：`派生类的operator=`必须要`调用基类的operator=`完成基类的赋值  
![](/images/ee50f62608119a41138a133b6f6d0cfa.png)
+ `Ⅳ`.**派生类的析构函数**会在被调用完成后**自动调用基类的析构函数清理基类成员**。因为这样才能保证派生类对象**先清理派生类**成员**再清理基类**成员的顺序（如果自己显式调用，会存在父类先析构问题）  
![](/images/9023c008337214e711de02d24e6e80eb.png)  
![](/images/8ccd150ac45b3d2f57b394acd31874d1.png)
+ `Ⅴ`.派生类对象初始化先调用基类构造再调派生类构造
+ `Ⅵ`.派生类对象析构清理**先调用派生类**析构**再调基类的析构**  
![](/images/b47838a67720a54025e737b3795cb7c4.png)

## 5.继承与友元
+ **友元关系不能继承**，也就是说**基类友元不能访问子类私有和保护成员**  
![](/images/df02e410cc858ff245521dd0a44b1651.png)

## 6.继承与[静态成员](https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&spm=1001.2101.3001.7020)
+ **基类定义了static静态成员，则整个继承体系里面只有一个这样的成员**。无论派生出多少个子类，都`只有一个static成员实例`  
![](/images/071c0b676c21905ba013cb2088bfa733.png)

## 7.菱形继承及菱形虚拟继承
### 7.1单继承与多继承
### 7.2菱形继承存在的问题及解决方案
![](/images/8e57f98d1c1b6d53c9fb8eb6a2f38af3.png)

+ 这里`加入域限定符`只能起到治标不治本的作用
+ 那么我们如何解决数据冗余的问题呢，**这里我们引入虚拟继承**，即可解决问题

### 7.3虚拟继承
+ **虚拟继承**可以**解决菱形继承的二义性和数据冗余的问题**。如上面的继承关系，在Student和Teacher的继承Person时使用虚拟继承，即可解决问题  
![](/images/fdebf25d4526e5d346bacc68729fd965.png)

### 7.4虚拟继承解决数据冗余和二义性的原理
+ 先分析菱形继承

![](/images/8b41e233a71006461f17dc8664c1975c.png)

+ 再分析菱形虚拟继承

![](/images/b4e9958ef2522e50fecbc5f2f317495e.png)

+ 总结：这里可以分析出D对象中将A放到的了对象组成的最下面，这个A  
同时属于B和C，**那么B和C如何去找到公共的A呢？** 这里是通过了B和C的两个指针，指向的一张表。**这两个指针叫虚基表指针**，**这两个表叫虚基表**。虚基表中存的偏移量。通过偏移量可以找到下面的A

## 8.总结与反思
+ 多继承中存在菱形继承，菱形继承就存在数据冗余和二义性的缺陷，那么解决这两个缺陷的方法就是虚拟继承，所以一般不要设计出菱形继承，否在在复杂度及性能上都有问题
+ 多继承是C++的缺陷之一

### 8.1继承和组合
+ 继承就是`is-a`，继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高  
![](/images/e59f944256b98bbb68f3de8c29624688.png)
+ 组合是`has-a`，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。 组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装  
![](/images/801230a11369054ab92c9c0e36c5f6bd.png)
+ 优先使用对象组合，而不是类继承
+ 继承和组合都是类设计角度的复用
+ 在软件工程中用组合更好，组合更符合`高类聚，低耦合`，更符合`is-a`关系用继承，更符合`has-a`用组合，都符合的情况用组合

  


> 来自: [C++之继承总结（继承的定义与格式，赋值转换，默认成员函数，菱形继承及菱形虚拟继承）_c++函数继承格式-CSDN博客](https://blog.csdn.net/qq_45657288/article/details/116140635)
>

