---
title: 面试问题总结----C/C++部分_c++ 面试-CSDN博客
date: '2025-01-01 02:26:20'
updated: '2025-01-01 02:31:22'
---
> 1、本栏用来记录社招找工作过程中的内容，包括基础知识学习以及面试问题的记录等，以便于后续个人回顾学习； 暂时只有2023年3月份，第一次社招找工作的过程；
>
> 2、个人经历： 研究生期间课题是[SLAM](https://so.csdn.net/so/search?q=SLAM&spm=1001.2101.3001.7020)在无人机上的应用，有接触SLAM、Linux、ROS、C/C++、DJI OSDK等；  
3、参加工作后（2021-2023年）岗位是[嵌入式软件开发](https://so.csdn.net/so/search?q=%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91&spm=1001.2101.3001.7020)，主要是服务器开发，Linux、C/C++、网络编程、docker容器、CMake、makefile、Shell脚本、JSON等。
>
> 4、求职岗位是嵌入式软件开发、C/C++开发、自动驾驶岗位开发等。
>

![](/images/86f287405ee9dce304a9dbb3435fb7f2.jpeg)

#### 文章目录
+ [一、知识部分](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#_12)
    - [1、c/c++内存模型](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#1cc_13)
    - [2 内联函数是什么，是不是只要声明为内联函数就一定会在原地展开](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#2__17)
    - [3、编译的四个过程](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#3_21)
    - [4 指针和引用有什么区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#4__27)
    - [5 函数重载](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#5__37)
    - [6 const关键字的作用](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#6_const_40)
    - [7 static关键字的作用](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#7_static_47)
    - [8 联合体和结构体的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#8__54)
    - [9 数组和指针的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#9__57)
    - [10 纯虚函数的作用](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#10__62)
    - [11 C++函数栈空间的最大值](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#11_C_65)
    - [12 vector和list的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#12_vectorlist_68)
    - [13 迭代器和指针的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#13__79)
    - [14 说一说STL迭代器是怎么删除元素的](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#14_STL_82)
    - [15 哪些成员变量必须在初始化列表初始化](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#15__87)
    - [16 sizeof和strlen的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#16_sizeofstrlen_90)
    - [17 C++中map与unordered_map的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#17_Cmapunordered_map_95)
    - [18 容器用过哪些，底层是什么](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#18__131)
    - [19 进程线程区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#19__141)
    - [20 你了解的锁机制？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#20__168)
    - [21 智能指针](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#21__185)
        * [21.1 使用智能指针的目的](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#211__186)
        * [21.2 实现原理](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#212__189)
        * [21.3 智能指针的种类](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#213__192)
        * [21.4 unique_ptr与shared_ptr的区别是什么？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#214_unique_ptrshared_ptr_198)
    - [22 C++11常用的新特性](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#22_C11_202)
        * [22.1 lambda表达式](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#221_lambda_203)
        * [22.2 智能指针](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#222__219)
        * [22.3 auto类型推导](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#223_auto_221)
        * [22.4 右值引用](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#224__222)
    - [23 static_cast和dynamic_cast的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#23_static_castdynamic_cast_223)
    - [25 C++的sort函数](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#25_Csort_230)
        * [25.1 sort函数排序原理](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#251_sort_231)
        * [25.2 sort函数对数组升序和降序排序](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#252_sort_236)
    - [26 C++中的extern关键字extern](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#26_Cexternextern_250)
    - [27 map能不能存放重复的key](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#27_mapkey_260)
    - [28 map中的key可不可以是自定义的类](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#28_mapkey_263)
    - [29 设计模式有了解过哪些](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#29__266)
    - [30 单个锁造成死锁的情况](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#30__288)
    - [31 在new一个对象的时候，内存的申请过程](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#31_new_290)
    - [32 push back和emplace back](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#32_push_backemplace_back_294)
        * [32.1 push back和emplace back的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#321_push_backemplace_back_295)
        * [32.2 push需要拷贝再插入，拷贝的过程是怎么样的，emplace不需要拷贝，那它插入的过程是怎么样的](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#322_pushemplace_297)
    - [33 父类指针调用子类虚函数的时候顺序是怎么样的](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#33__299)
    - [34 虚函数的实现过程，](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#34__300)
    - [35 深拷贝和浅拷贝](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#35__308)
    - [36 设置虚析构函数的好处](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#36__312)
    - [37、虚函数的实现原理](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#37_316)
    - [38、什么情况下析构函数要用虚函数？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#38_319)
    - [39、shared_ptr在多线程里是线程安全的嘛？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#39shared_ptr_324)
    - [40、原子量和加锁有什么区别？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#40_325)
    - [41、reserve( ) 和resize( ) 函数的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#41reserve__resize___331)
    - [42、std::function与std::bind](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#42stdfunctionstdbind_335)
    - [43 Lambda表达式工作原理](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#43_Lambda_348)
    - [44 C++仿函数](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#44_C_359)
    - [45 C++友元函数](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#45_C_363)
    - [46 C++的静态绑定和动态绑定](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#46_C_371)
        * [静态绑定和动态绑定的概念](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#_372)
        * [静态绑定和动态绑定的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#_382)
    - [51、如何避免一个线程独占cpu？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#51cpu_394)
    - [42、vector跟C语言的数组有什么区别？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#42vectorC_397)
    - [43、vector如何做到可以不断扩展容量呢？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#43vector_400)
    - [44、C++里的转移语义有了解嘛？涉及到右值引用；&&意思是什么？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#44C_405)
    - [45 &&的意思是什么？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#45__416)
    - [46、C++11支持函数返回值为一个对象实例，原因是什么？](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#46C11_422)
    - [47 static const和const static的区别](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#47_static_constconst_static_425)
    - [48 类模版](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#48__428)
+ [二、做题](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#_476)
    - [1 写一个单链表，实现插入和删除，用class来封装](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#1_class_477)
    - [2 获取一个32位整数中，出现次数最多的数字](https://blog.csdn.net/AnChenliang_1002/article/details/131197674#2_32_478)

## 一、知识部分
### 1、c/c++内存模型
C++ 内存分为栈、堆、数据段、BSS段、代码段、映射区  
栈是存放函数的局部变量和函数参数等，由编译器自动分配和释放。堆是动态分配的内存空间，必须由程序员手动申请和释放。数据段是存储程序中已经初始化的全局变量和静态变量。BSS段是存储未初始化的全局变量和静态变量，以及所有被初始化为0的全局变量和静态变量。代码段是存放代码，函数，以及字符串常量的地方。映射区存储了动态链接库以及调用mmap函数进行的文件映射

### 2 内联函数是什么，是不是只要声明为内联函数就一定会在原地展开
在函数声明或定义前加inline关键字，则该函数被称为内联函数。c++编译器会直接将调用内联函数的地方直接展开成相对应的指令，没有了函数栈帧的开销，从而提高了程序的运行效率。  
不是，当代码很长，或者循环递归不会展开。

### 3、编译的四个过程
预处理阶段：引入头文件，宏替换，删除注释…，生成以.i为结尾的预编译文件  
编译阶段：检查语义语法规错误，如果没有错误则将代码解释为汇编汇编，生成以.s为结尾的汇编文件  
汇编阶段： 将汇编代码解释为二进制的cpu指令，生成.o为结尾的可重定向目标文件  
链接阶段： 将多个目标文件及所需要的库连接成最终的可执行目标文件

### 4 指针和引用有什么区别
引用必须在定义时初始化，指针没有要求。  
引用在初始化引用一个实体后，不能更改引用实体而指针可以。  
没有NULL引用，但是有NULL指针  
有多级指针，但是没有多级引用  
访问实体时，指针需要解引用，而引用是编译器自行处理  
引用比指针用起来相对安全  
引用自加自减都是实体值的改变，而指针自加自减是地址的偏移  
sizeof求的是指针的大小，4个字节或者8个字节；而sizeof求引用变量时求实体变量的大小

### 5 函数重载
函数重载是用来描述同名函数具有相同或者相似功能，在同一作用域中，当两个函数的函数名相同但是参数列表不同(个数，类型)，这两个函数就形成了函数重载

### 6 const关键字的作用
const表示只读；  
1、const修饰的局部变量或者全局变量声明时必须初始化，且该变量只能读不能写  
2、const修饰指针时，如果const在`*` 号的左边，则修饰的是指针指向的内容不能变，const在 `*` 号右边时，则修饰的是指针，表示指针的指向不能发送改变。如果 `*`号左边和右边都有const，则表示指针指向的内容和指针本身都是不可变的  
3、const修饰的成员函数不能修改对象的成员变量  
4、const修饰的函数参数在函数体内不能被修改

### 7 static关键字的作用
1、未初始化的静态变量的值默认为0  
2、修饰全局变量或者函数时，则该变量和函数只能在当前文件可见  
3、修饰局部变量时，变量的生命周期随程序，只有程序结束，变量的生命周期才结束  
4、static修饰的成员函数没有this指针，不能调用非静态成员函数和非静态变量，只能通过类名来访问  
5、static修饰的成员变量在整个类中只有一份，被所有对象共享，必须在类外初始化，也是只能通过类名来访问

### 8 联合体和结构体的区别
结构体和联合体都是由多个不同的类型变量组成的，但是联合体所有成员共用一块内存，而结构体每个成员都有各自的内存。给联合体的不同变量赋值, 会覆盖掉其他变量的值，而给结构体的不同变量赋值是互不影响的。

### 9 数组和指针的区别
数组是保存多个同类型数据的集合；而指针是一个变量，用来保存其他变量的内存地址的  
sizeof数组是求数组中全部元素占内存空间的大小；而sizeof指针求的是指针的大小，不是4个字节就是8个字节  
当使用数组作为函数参数时会退化为指针

### 10 纯虚函数的作用
为了方便使用多态特性，我们会在基类中定义纯虚函数。但在很多情况下，基类本身生成对象是不合情理的。如果将函数定义为纯虚函数，则编译器要求在派生类中必须进行重写来实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成实例化生成对象

### 11 C++函数栈空间的最大值
Linux下默认为8M，可以调整

### 12 vector和list的区别
区别：  
1、vector底层是通过数组实现的；list底层是通过链表来实现的  
2、vector支持随机访问；list不支持随机访问  
3、vector迭代器是原生指针；list迭代器是封装链表结点的一个类  
4、vector在插入和删除时可能会导致迭代器失效；list只在删除的时候会导致迭代器的失效  
5、vector不容易造成内存碎片，空间利用率高；list容易造成内存碎片，空间利用率低  
6、vector在非尾插尾删的时间复杂度都为O(n)，list在任何地方插入和删除的时间复杂度都为O(1)  
使用场景：  
如果频繁地随机访问，且不关心插入删除效率，就使用vector；具有大量插入和删除操作，而不关心随机访问，就是用list

### 13 迭代器和指针的区别
迭代器不是指针，而是类模板。它模拟了指针的一些功能，通过重载了指针的一些操作符，封装了指针，提供了比指针更高级的行为

### 14 说一说STL迭代器是怎么删除元素的
对于vector，deque来说，删除元素后，后边的每个元素的迭代器都会失效，但是后边的每个元素都会向前移动一个位置。返回的是下一个有效的迭代器  
对于list来说，它使用了不连续的内存，删除元素后会返回下一个有效的迭代器  
对于关联容器map，set来说，删除元素后，当前元素迭代器失效，但是其结构是红黑树，删除当前元素不会影响到下一个元素的迭代器，所以调用erase之前，记录下一个元素的迭代器即可

### 15 哪些成员变量必须在初始化列表初始化
引用、const、没有默认构造函数的自定义成员变量

### 16 sizeof和strlen的区别
+ sizeof是一个操作符，strlen是库函数
+ sizeof的参数可以是数据的类型，也可以是变量，而strlen的参数只能是以\0结尾的字符串
+ sizeof计算的是数据对象占内存的大小，而strlen计算的是字符串的实际长度

### 17 C++中map与unordered_map的区别
（1）头文件

```cpp
map: #include < map >
unordered_map: #include < unordered_map >
```

（2）内部实现机理

+ map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。
+ unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。  
（3）优缺点以及适用处

**map**

优点：

+ 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
+ 红黑树，内部实现一个红黑书使得map的很多操作在lgnlgn的时间复杂度下就可以实现，因此效率非常的高。  
缺点：
+ 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间。
+ 适用处，对于那些有顺序要求的问题，用map会更高效一些。

**unordered_map**

**优点**：

+ 因为内部实现了哈希表，因此其查找速度非常的快。  
**缺点**：
+ 哈希表的建立比较耗费时间。
+ 适用处，对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map。

（4）note  
对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的。

### 18 容器用过哪些，底层是什么
+ vector：底层数组
+ list：底层链表
+ unordered_map：底层哈希表
+ map：底层红黑树

### 19 进程线程区别
进程是`资源分配`的最小单位，线程是`CPU调度`的最小单位。

做个简单的比喻：进程=火车，线程=车厢

+ 线程在进程下行进（单纯的车厢无法运行）
+ 一个进程可以包含多个线程（一辆火车可以有多个车厢）
+ 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
+ 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
+ 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
+ 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
+ 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
+ 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－“互斥锁”
+ 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

```cpp
进程 是系统分配资源的最小单位。
  线程 是系统调度的最小单位。
```

线程是程序最基本的运行单位，而进程是不能运行的，运行的是进程中的线程。创建进程时，系统会自动创建一个主线程来运行进程中的数据信息。

我们运行`main()`函数的时候，就会创建一个主进程和一个主线程，当我们在主线程中创建更多的子线程后：  
调用`exit()`函数：主进程和主线程都退出，子线程自然也要退出。  
调用`pthread_exit()`函数：主线程退出，但是主进程依旧存在，所以进程中的子线程可以继续运行。

在程序中使用多进程多线程时，曾经出现ctrl c强制退出程序后，仍然有线程在后台执行，要手动kill掉。是因为父进程死亡后，主进程中的线程跟随主进程一起退出了，而子进程由系统1号进程进行管理，所以子进程中的线程还可以继续运行。这就导致我在调试运行程序的时候经常会出现报错，原因是因为后台中的子进程还在运行导致的。所以在处理进程和线程时，要几时对线程和进程资源进行回收，避免出错。

### 20 你了解的锁机制？
（1）互斥锁：mutex，保证在任何时刻，都只有一个线程访问该资源，当获取锁操作失败时，线程进入阻塞，等待锁释放。

（2）读写锁：rwlock，分为读锁和写锁，处于读操作时，可以运行多个线程同时读。但写操作同一时刻只有一个线程获得写锁。

互斥与读写锁的区别：

+ （a）读写锁区分读锁和写锁，而互斥锁不区分；
+ （b）互斥锁同一时间只允许一个线程访问，无论读写；读写锁同一时间只允许一个线程写，但可以多个线程同时读。

（3）自旋锁：spinlock，在任何时刻只能有一个线程访问资源。但获取锁操作失败时，不会进入睡眠，而是原地自旋，直到锁被释放。这样节省了线程从睡眠到被唤醒的时间消耗，提高效率。

（4）条件锁：就是所谓的条件变量，某一个线程因为某个条件未满足时可以使用条件变量使该程序处于阻塞状态。一旦条件满足了，即可唤醒该线程（常和互斥锁配合使用）。

（5）信号量。

### 21 智能指针
#### 21.1 使用智能指针的目的
为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。

#### 21.2 实现原理
智能指针实现的原理就是通过调用析构函数来间接释放new的内存。

#### 21.3 智能指针的种类
1、共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 `use_count()` 查看资源的所有者的个数，可以通过 `unique_ptr`、`weak_ptr` 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。  
2、独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 `unique_ptr` 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。  
3、弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。  
智能指针的实现原理： 计数原理。

#### 21.4 unique_ptr与shared_ptr的区别是什么？
1、`unique_ptr`,我习惯把叫它“独占指针”，其特点是该指针指向的资源独占，不能通过拷贝构造让其他的智能指针共指同一个内存资源。适合的场景是指针所指的内存资源仅被一处使用，使用完就自动释放了，不涉及共享。  
2、`shared_ptr`,我也叫它“共享指针”。使用场景是：一处申请的内存资源，只需要传递指针就可以多处访问。当然了，相比unique_ptr，为了确定何时释放内存资源，需要有个变量存引用计数，当引用计数为0也就表示没有指针指向这片内存区域了，触发析构函数自动释放内存资源。

### 22 C++11常用的新特性
#### 22.1 lambda表达式
C++ 11 中的 Lambda 表达式用于定义并创建匿名的函数对象，以简化编程工作。

比如：

```cpp
[&](){return (a+b);}
```

定义了一个匿名函数，入参列表为空，函数里执行的操作是返回a+b；

+ [] 不捕获任何变量。
+ [&] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。
+ [=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。
+ [=，&foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。
+ [bar] 按值捕获 bar 变量，同时不捕获其他变量。
+ [this] 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 & 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。this 指针只能按值捕获 [this] ，不能按引用捕获 [&this] 。

#### 22.2 智能指针
参考 21 智能指针

#### 22.3 auto类型推导
#### 22.4 右值引用
### 23 static_cast和dynamic_cast的区别
尤其说下，继承关系时，即向上转型和向下转型时的区别

+ 对于上行转换，static_cast和dynamic_cast效果一样，都安全；
+ 对于下行转换：你必须确定要转换的数据确实是目标类型的数据，即需要注意要转换的父类类型指针是否真的指向子类对象，如果是，static_cast和dynamic_cast都能成功；如果不是static_cast能返回，但是不安全，可能会出现访问越界错误，而dynamic_cast在运行时类型检查过程中，判定该过程不能转换，返回NULL。

### 25 C++的sort函数
#### 25.1 sort函数排序原理
`sort()`并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。

所以无论元素初始时为何种状态，sort()的平均排序复杂度为均为`O(N*log2(N))` ，具有不错的的性能，在刷算法题时，可以直接使用`sort()`来对数据进行排序，而不需手动编写排序函数。

#### 25.2 sort函数对数组升序和降序排序
`vector<int> arr`是要排序的目标数组；  
升序：

```cpp
sort(arr.begin(), arr.end())
```

降序：

```cpp
sort(arr.begin(), arr.end(), greater<int>())
```

### 26 C++中的extern关键字extern
1）声明外部变量

各个文件定义的全局变量是互相透明的，在链接时，要将各个文件的内容合为一体，因此某些文件中定义的全局变量名相同的话，在这个时候就会出现错误，也就是会出现重定义的错误。extern的原理很简单，就是告诉编译器，现在编译的文件中，这个标识符虽然没有在本文中定义，但是在别的文件中定义的全局变量。  
比如在a文件中定义全局变量 int acl = 0;在另一个文件中int acl;则会报错重复定义；但是写成extern int acl;则不会报错

2）在C++文件中调用C定义的变量

因为C++中新增了诸如重载新特性，所以全局变量和函数名编译后的命名方式有很大区别，使用`extern "C"{ int iRI;}`告诉编译器，iRI是使用C方式编译的。

### 27 map能不能存放重复的key
map是不允许有key相同的键值对存在的。

### 28 map中的key可不可以是自定义的类
C++ map的键类型可以是一个类，比如键类型可以是C++标准库中的string类，但是对作为键的类有一个约束，那就是这个类必须定义小于操作符，也就是要重载小于运算操作符（C++标准库的string类就定义了小于操作符）。

### 29 设计模式有了解过哪些
（1）单例模式

概念：是指在内存中只会创建且创建一次对象的设计模式

优点：

1.保证一个类只有一个实例，并提供一个访问它的全局访问点，使得系统中只有一个唯一的一个对象实例。这样就防止其他对象对自己的实例化，确保所有的对象都访问一个实例

2.由于在系统内存中只存在一个对象，因此可以节约系统的资源，提高系统的性能

缺点：

就是不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态

实现要点：

实现的原理就是将这个类的构造函数设为private，对外只提供一个static的GetInstance的接口获取这个类的静态对象，当然这个静态对象也是private的，

在类中，要构造一个实例，就必须调用类的构造函数，并且为了保证全局只有一个实例，需要防止在外部调用类的构造函数而构造实例，需要将构造函数的访问权限标记为private，同时阻止拷贝创建对象时赋值拷贝对象，因此也将它们声明并权限标记为private；另外，需要提供一个全局访问点，就需要在类中定义一个static函数，返回在类内部唯一构造的实例

### 30 单个锁造成死锁的情况
### 31 在new一个对象的时候，内存的申请过程
new的原理：调用operator new函数申请空间，在申请空间上执行构造函数，完成对象的构造，返回正确的指针  
delect的原理：在空间上执行析构函数，完成对象中资源的清理工作；调用operator delect函数释放对象的空间

### 32 push back和emplace back
#### 32.1 push back和emplace back的区别
emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。

#### 32.2 push需要拷贝再插入，拷贝的过程是怎么样的，emplace不需要拷贝，那它插入的过程是怎么样的
push_back() 在底层实现时，先调用构造函数创建元素，然后调用移动构造函数（如果没有才会调用拷贝构造函数）将元素插入到容器里。emplace_back() 在实现时，则是直接在容器尾部调用构造函数即可。

### 33 父类指针调用子类虚函数的时候顺序是怎么样的
### 34 虚函数的实现过程，
1、用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。  
2、存在虚函数的类都有一个一维的虚函数表叫做虚表。每一个类的对象都有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。  
3、多态性是一个接口多种实现，是面向对象的核心。分为编译多态性和运行多态性。  
4、运行多态用虚函数来实现，结合动态绑定。  
5、纯虚函数是虚函数再加上=0。并且该函数只有声明，没有实现。  
6、抽象类是指包括至少一个纯虚函数的类。

### 35 深拷贝和浅拷贝
1、浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。

2、深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。

### 36 设置虚析构函数的好处
1、为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。  
2、当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。

### 37、虚函数的实现原理
1、用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。  
2、存在虚函数的类都有一个一维的虚函数表叫做虚表。每一个类的对象都有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。

### 38、什么情况下析构函数要用虚函数？
若存在类的继承关系,而且基类指针指向派生类对象时,一般需要将析构函数声明为虚函数,不然在使用基类指针进行析构时会无法调用派生类的析构函数而造成内存泄漏等问题

一般在存在继承场景的对象层次中，请记得将基类的析构函数声明为虚函数。

### 39、shared_ptr在多线程里是线程安全的嘛？
### 40、原子量和加锁有什么区别？
原子量atomic来实现无锁并发，`std::atomic<int> variable;`  
原子量的原理：一旦我们`用atomic来修饰某个变量`，那么这个变量的操作就不可被打断。即使有很多个线程都可以访问操作这个变量，但由于这个变量的原子性，不可中断的特性，就不会出现某个线程刚操作了一半，却被另一个线程篡改的情况，因此也就实现了并发的安全保证。并且`无锁并发的效率，理论上要高于有锁`。

原子量和锁的区别是，`基本上原子量能做的，通过加锁也都能做到`。但`反之则不行`，原子量只能保证自己是不被中断的，但无法对代码段的执行提供保护。

### 41、reserve( ) 和resize( ) 函数的区别
`reserve()`： serve 是“保留”的词根，所以是用来预留容量的，并不会改变容器的有效元素个数。即用reserve（）开辟空间时，仅改变capacity（容器最大容量）大小，与size（容器当前有效元素）无关。  
`resize()`： size 是“大小”的意思，它主要用来调整容器有效元素的个数，有时候也会造成容量的改变。因此用resize()开辟空间时，会对**增加的空间全部进行初始化**，使得`有效元素个数增加`。

### 42、std::function与std::bind
C++中函数指针的用途非常广泛，例如回调函数，接口类的设计等，但函数指针始终不太灵活，它只能指向全局或静态函数，对于类成员函数、lambda表达式或其他可调用对象就无能为力了，因此，C++11推出了std::function与std::bind这两件大杀器。  
**1、std::function()**  
函数指针的用法非常简单，但是它只能指向全局或静态函数，这有点太不灵活了，而且我们都知道在C/C++中，全局的东西都很可怕，稍有不慎就会被篡改或随便调用。

在C++11之后，我们多了一种选择，std::function，使用它时需要引入头文件functional。**std::function可以说是函数指针的超集，它除了可以指向全局和静态函数**，`还可以指向彷函数，lambda表达式，类成员函数，甚至函数签名`（C++中的函数签名(function signature)：包含了一个函数的信息，包括函数名、参数类型、参数个数、顺序以及它所在的类和命名空间，普通函数签名并不包含函数返回值部分）不一致的函数，可以说几乎所有可以调用的对象都可以当做std::function，当然对于后两个需要使用std::bind进行配合，

缺点：  
std::function填补了函数指针的灵活性，但会对调用性能有一定损耗，经测试发现，在调用次数达**10亿次**时，函数指针比直接调用要**慢2秒**左右，而std::function要比函数指针**慢2秒**左右，这么少的损耗如果是对于调用次数并不高的函数，替换成std::function绝对是划得来的。

**2、std::bind**  
std::function可以指向类成员函数和函数签名不一样的函数，其实，这两种函数都是一样的，因为类成员函数都有一个默认的参数，this，作为第一个参数，这就导致了类成员函数不能直接赋值给std::function，这时候我们就需要std::bind了，简言之，`std::bind的作用就是转换函数签名，将缺少的参数补上，将多了的参数去掉，甚至还可以交换原来函数参数的位置`，

### 43 Lambda表达式工作原理
`operator()`：重载操作符

编译器会把一个Lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符，实现了一个`operator()`方法  
编译器实现 lambda 表达式大致分为一下几个步骤：

1、创建 lambda匿名类，实现构造函数，使用 lambda 表达式的函数体重载 `operator()`（所以 lambda 表达式 也叫匿名函数对象）  
2、创建 lambda 对象  
3、通过对象调用 `operator()`

### 44 C++仿函数
`operator()`：重载操作符  
仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，仿函数与Lamdba表达式的作用是一致的。

### 45 C++友元函数
`友元 (friend)` 可以访问与其有好友关系的类中的**私有成员** (有限制的共享).

友元包括友元函数和友元类:

1、友元函数: 如果在本类以外的其他地方定义的函数, 在类体重用 friend 进行声明. 此函数就称为本类的有元函数, 友元函数可以访问这个类中的私有成员  
2、友元类: 类 A 将另一个类 B 声明为其友元类, 友元类 B 中的所有函数都是 A 类的友元函数, 可以访问 A 类中的所有成员

### 46 C++的静态绑定和动态绑定
#### 静态绑定和动态绑定的概念
C++ 在面向对象编程中，有着静态绑定和动态绑定的定义，为了了解这两个概念，首先先简单阐述一些名词：

+ 静态类型：对象在声明时使用的类型，在编译期就已经确定
+ 动态类型：指针变量或引用变量所指向对象的类型，在运行期才能确定
+ 静态绑定：绑定的是静态类型，对象的函数和属性依赖于绑定的静态类型，发生在编译期
+ 动态绑定：绑定的是动态类型，对象的函数和属性依赖于绑定的动态类型，发生在运行期

非虚函数一般都是静态绑定，虚函数则是动态绑定。

#### 静态绑定和动态绑定的区别
1、静态绑定发生在编译期，动态绑定发生在运行期  
2、对象的动态类型可以更改，但是静态类型无法更改  
3、要想实现动态，必须使用动态绑定  
4、在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定

### 51、如何避免一个线程独占cpu？
1、尽量不要涉及递归循环  
2、使用条件变量，notify、wait的机制

### 42、vector跟C语言的数组有什么区别？
vector类型和数组类型的基本功能都是一样的，就是存储同类元素，但是他与数组`最大的区别就是可以实现动态存储`。  
**vector相当于动态数组**，比如 char str[100];只能存储100个字符。vector可以动态增长。

### 43、vector如何做到可以不断扩展容量呢？
当数据超过vector分配的大小，vector会在内存中创建一个新的数组，然后将旧数组中的数据复制到新数组中并删除旧数组。

那么它是怎么实现自动扩容的呢？其实关键点就是对于容器里的`元素数量`进行判断，当容器的存储数量**已经达到容量时**，那么就需要进行一个倍增扩容了。整体的一个扩容流程为：`申请新的内存空间`（空间大小为原空间的两倍或一点五倍）—> `把原空间的元素拷贝到新的空间里` —> `释放原空间` —> `数组指针指向新空间`。

### 44、C++里的转移语义有了解嘛？涉及到右值引用；&&意思是什么？
右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。

**转移语义**是和**拷贝语义**相对的，可以类比文件的**剪切**与**拷贝**，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。

通过转移语义，临时对象中的资源能够转移其它的对象里。

在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。**要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符**。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。

普通的函数和操作符也可以利用右值引用操作符实现转移语义。

### 45 &&的意思是什么？
第一种用途：“与”（AND）逻辑运算符。做条件判断时，&&常用来连接多个条件。

第二种用途：右值引用，这个功能自C++11起才可用。移动语义是C++11新增的重要功能，其重点是对右值的操作。右值可以看作程序运行中的临时结果，右值引用可以避免复制提高效率。

### 46、C++11支持函数返回值为一个对象实例，原因是什么？
当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。

### 47 static const和const static的区别
一个是静态常量，一个是常量静态；使用上好像没什么区别。

### 48 类模版
模板可以帮助我们提高代码的可用性, 可以帮助我们减少开发的代码量和工作量.

1、模板实例化：模板的实例化分为显示实例化和隐式实例化，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板；不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的

2、模板具体化：当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。

3、代码示例：

```cpp
#include <iostream>
using namespace std;

// #1 模板定义
template<class T>
struct TemplateStruct
{
TemplateStruct()
{
    cout << sizeof(T) << endl;
}
};

// #2 模板显示实例化
template struct TemplateStruct<int>;

// #3 模板具体化
template<> struct TemplateStruct<double>
{
TemplateStruct() {
    cout << "--8--" << endl;
}
};

int main()
{
    TemplateStruct<int> intStruct;
    TemplateStruct<double> doubleStruct;

    // #4 模板隐式实例化
    TemplateStruct<char> llStruct;
}
```

## 二、做题
### 1 写一个单链表，实现插入和删除，用class来封装
### 2 获取一个32位整数中，出现次数最多的数字
整体思路：

> 要求： 统计一个整数中出现最多的数字。如果数字个数一样，则以最大的数字为准，例如 1 输出 1，121 输出 1，23231 输出 3。
>

针对这个问题，处理步骤可以分为2步：

**第一步**：首先抽离整数中的每个数字，并且放到该数字对应的桶数组中，桶数组是一个长度为10的数组，其中数组的每个索引都表示整数中可能出现的数字，数组索引0到9刚好表示0到9这10个数字。至于抽离数字可以先将整数对10取模，得到的最低位的数字，再将该数字对应的数组位置的元素加1，接着再将整数除以10，这样到整数为0时，就已抽离出整数中的所有数字。

**第二步**：现在桶数组中的10个元素表示的是整数中所有数字的出现次数，例如573257抽离完后数组中所因为2,3,5,7的四个位置的值应该为1，1，2，2。循环得到数组中的最大元素，并且保留索引。如果有两个数字出现次数一样，遍历桶数组也能获取整数中其中最大的数字，大家仔细想想就知道了。

```cpp
int NumberStat(int Target)
{
    //首先将输入的数字的各个位置的值放到桶数组中
    /* 
     * 循环地对整数对10取模，并将得到的数字放入其对应的桶中 ，即a[0]放的是0出现的次数，a[1]放的是1出现的次数，以此类推
     * 接着对整数除10，当numer为0时，所有的数字都已抽离 
     */ 
    int arr[10] = {0};
    while(0 != Target)
        {
            int num = Target%10;//余数便是位置
            arr[num] ++;//记录num出现的次数
            Target = Target/10;
        }
    int Max = arr[0];//Max存放最多的次数
    int index_max = 0;//index_max存放出现次数最多的数字
    for(int i = 0;i<=9;i++)
        {
            if(Max < arr[i])
            {
                Max = arr[i];
                index_max = i;
            }            
        }
    cout << "最大的次数是" << Max << "次"<<endl;
    cout << "最大的次数对应的数字是" << index_max <<endl;

    return 0;
}
```

  


> 来自: [面试问题总结----C/C++部分_c++ 面试-CSDN博客](https://blog.csdn.net/AnChenliang_1002/article/details/131197674)
>

