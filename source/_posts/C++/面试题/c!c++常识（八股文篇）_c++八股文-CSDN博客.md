---
title: c/c++常识（八股文篇）_c++八股文-CSDN博客
date: '2025-01-01 01:56:33'
updated: '2025-01-01 01:58:22'
---
###### 1、new和malloc
+ 都说c语言有没有学好就是看两样东西（指针与内存）
+ 1）malloc和free是c++/c语言的**库函数**，需要头文件支持stdlib.h；new和delete是C++的**关键字**，不需要头文件，需要编译器支持；
+ 2）使用new操作符申请内存分配时，无需指定内存块的大小，编译器会根据类型信息**自行计算**。而malloc则需要显式地支持所需内存的大小。
+ 3）**new操作符**内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故new是符合类型**安全性的操作符**。而malloc内存分配成功则是返回void，需要通过强制类型转换将void指针转换成我们需要的类型。
+ 4）new内存分配失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL。

###### 2、extern”C” 的作用
+ 我们可以在C++中使用C的已编译好的函数模块，这时候就需要用到extern”C”。也就是extern“C” 都是在c++文件里添加的。
+ extern在链接阶段起作用（四大阶段：预处理( E )–>编译( S )–>汇编( c )–>链接）。
+ 预处理（.c文件=>.i文件）、编译阶段（.i文件=>.s文件）、汇编阶段（.s文件=>.o文件）、链接阶段（将多个.o文件以及所需的库进行连接=>.exe文件）

###### 3、[字符串](https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020)操作函数
+ 字符串初始化函数 memset

```cpp
char *pstr;
pstr = (char*)malloc(128);//malloc 1.要防止内存泄漏的问题

if(pstr == NULL){//申请内存可能会失败，要对返回值作判断
    printf("内存申请失败\n");
    exit(-1);
}
memset(pstr,'\0',128);  //初始化的对象  初始化的字符    多大
```

+ 常用拷贝函数之memcpy（不限于字符串）

```cpp
/*
@	形参为void*  返回也是void* 不限于字符串的复制
*/
void *memcpy(void *dest, void *src, unsigned int count);
```

+ 拷贝函数之strcpy（strcpy函数会导致内存溢出）

```cpp
/*
@	strcpy拷贝函数不安全，他不做任何的检查措施，也不判断拷贝大小，不判断目的地址内存是否够用
@	功能:把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间
@	说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。
@	返回值：返回指向dest的指针。
*/
char * strcpy(char * dest, const char *src);

/*
@	strncpy拷贝函数，虽然计算了复制的大小，但是也不安全，没有检查目标的边界
@	strncpy_s是安全的
@	destinin：表示复制的目标字符数组；
@	source：表示复制的源字符数组；
@	maxlen：表示复制的字符串长度。
*/
char *strncpy(char *destinin, char *source, int maxlen);
```

+ 拼接函数之strcat

```cpp
/*
@ 功能:把src所指向的字符串（包括“\0”）复制到dest所指向的字符串后面（删除dest原来末尾的“\0”）。要保证dest足够长，以容纳被复制进来的*src。*src中原有的字符不变。返回指向dest的指针。
@ 说明:src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。
*/
extern char *strcat(char *dest, const char *src);
```

+ 比较函数之strcmp

```cpp
/*	
@ ..
*/
int strcmp(char*str1, char* str2);
```

###### 4、[static](https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020)的用法（定义和用途）（必考）
+ 1）**用static修饰局部变量**：使其变为静态存储方式(静态数据区)，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中。
+ 2）**用static修饰全局变量**：使其只在本文件内部有效，而其他文件不可连接或引用该变量。
+ 3）**用static修饰函数**：对函数的连接方式产生影响，使得函数只在本文件内部有效，对其他文件是不可见的（这一点在大工程中很重要很重要，避免很多麻烦，很常见）。这样的函数又叫作静态函数。使用静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外也是对函数本身的一种保护机制。

###### 5、const的用法（定义和用途）（必考）
+ const主要用来修饰变量、函数形参和类成员函数：
+ 1）用const修饰常量：定义时就初始化，以后不能更改。
+ 2）用const修饰形参：func(const int a){};该形参在函数里不能改变
+ 3）用const修饰类成员函数：该函数对成员变量只能进行只读操作，就是const类成员函数是不能修改成员变量的数值的。
+ 被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
+ 衍生的语法

```cpp
const int a; //变量a的值不可更改
int const a; //变量a的值不可更改

const int *a;//指针变量a指向的内容不可更改

int * const a; //指针变量a指向的地址不可更改

int const * a const;//指针变量a指向的地址和变量都不可更改
```

###### 6、volatile作用和用法
+ 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量在内存中的值，而不是使用保存在寄存器里的备份（虽然读写寄存器比读写内存快）。
+ 当一个被volatile关键字修饰的变量被一个线程修改的时候，其他线程可以立刻得到修改之后的结果。一个线程向被volatile关键字修饰的变量写入数据的时候，虚拟机会强制它被值刷新到主内存中。当一个线程用到被volatile关键字修饰的值的时候，虚拟机会强制要求它从主内存中读取。
+ volatile 禁止指令重排，保证了有序性
+ 以下几种情况都会用到volatile： 
    - 1、并行设备的硬件寄存器（如：状态寄存器）
    - 2、一个中断服务子程序中会访问到的非自动变量
    - 3、多线程应用中被几个任务共享的变量**线程安全**

###### 7、const常量和#define的区别（编译阶段、安全性、内存占用等）
+ 用#define max 100 ; 定义的常量是没有类型的（不进行类型安全检查，可能会产生意想不到的错误），所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，define所定义的宏变量在预处理阶段的时候进行替换，在程序中使用到该常量的地方都要进行拷贝替换；
+ 用const int max = 255 ; 定义的常量有类型（编译时会进行类型检查）名字，存放在内存的静态区域中，在编译时确定其值。在程序运行过程中const变量只有一个拷贝，而#define所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比const变量的大得多

###### 8、变量的作用域（[全局变量](https://so.csdn.net/so/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020)和局部变量）
+ 全局变量：在所有函数体的外部定义的，程序的所在部分（甚至其它文件中的代码）都可以使用。全局变量不受作用域的影响（也就是说，全局变量的生命期一直到程序的结束）。
+ 局部变量：出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为自动变量，因为它们在进入作用域时自动生成，离开作用域时自动消失。关键字auto可以显式地说明这个问题，但是局部变量默认为auto，所以没有必要声明为auto。
+ 局部变量可以和全局变量重名，在局部变量作用域范围内，全局变量失效，采用的是局部变量的值。

###### 9、sizeof 与strlen （字符串，数组）
+ 1.如果是数组

```cpp
#include<stdio.h> int main()
{ 
	int a[5]={1,2,3,4,5};
	printf(“sizeof 数组名=%d\n”,sizeof(a));
	printf(“sizeof *数组名=%d\n”,sizeof(*a)); 
}
//结果：
//sizeof 数组名=20 
//sizeof *数组名=4
```

+ 2.如果是指针，sizeof只会检测到是指针的类型，指针都是占用4个字节的空间（32位机）。
+ sizeof是什么？是一个操作符,也是关键字，就不是一个函数，这和strlen()不同，strlen()是一个函数。那么sizeof的作用是什么？返回一个对象或者类型所占的内存字节数。我们会对sizeof()中的数据或者指针做运算吗？基本不会。例如sizeof(1+2.0),直接检测到其中类型是double,即是sizeof(double) = 8。如果是指针，sizeof只会检测到是指针的类型，指针都是占用4个字节的空间（32位机）。

```cpp
char *p = "sadasdasd"; 
sizeof(p):4 
sizeof(*p):1//指向一个char类型的，*p指向第一个元素，（每个元素的大小）
```

+ **除非使用strlen()，仅对字符串有效，直到’\0’为止了，计数结果不包括\0**。
+ 要是非要使用sizeof来得到指向内容的大小，就得使用数组名才行， 如：

```cpp
char a[10]; 
sizeof(a):10 //检测到a是一个数组的类型。
sizeof(*a):1//每个元素
```

###### 10、经典的sizeof(struct)和sizeof(union)内存对齐
+ **内存对齐作用**： 
    - 1.平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
    - 2.性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
+ **结构体struct内存对齐的3大规则:**
    - 1.对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍；
    - 2.结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍；
    - 3.如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型。

```cpp
# pragma pack(1)

struct fun{
	int i;//4
	double d;//8
	char c;//1
};
//sizeof(fun) = 13

struct CAT_S{
	int ld;// 4/4
	char Color;// 1/1
	unsigned short Age;// 2/2
	char* Name;// 4/8
	void(*Jump)(void);// 4/8
}Garfield;
//关于字节对齐（按几字节对齐，是根据结构体的最长类型决定的，这里是int是最长的字节，所以按4/8字节对齐）
//使用32为编译，为15字节，且要求4字节对齐的话就是16字节。
// 使用64为编译，为23字节，且要求8字节对齐的话就是24字节。

//64位 
struct C {
	double t; //8 1111 1111 
	char b; //1 1 
	int a; //4 0001111 
	short c; //2 11000000 
};
sizeof(C) = 24; //注意：1 4 2 不能拼在一起
//char是1，然后在int之前，地址偏移量得是4的倍数所以char后面补三个字节，也就是char占了4个字节，
//然后int四个字节，
//最后是short，只占两个字节，但是总的偏移量得是double的倍数，也就是8的倍数，所以short后面补六个节
```

+ **联合体union内存对齐的2大规则:**
    - 1.找到占用字节最多的成员；
    - 2.union的字节数必须是占用字节最多的成员的字节的倍数，而且需要能够容纳其他的成员

```cpp
// x64
typedef union{
long i;
int k[5];
char c;
}D
// 要计算union的大小,首先要找到占用字节最多的成员,本例中是long,占用8个字节.int k[5]中都是int类型,仍然是占用4个字节的,，然后union的字节数必须是占用字节最多的成员的字节的倍数,而且需要能够容纳其他的成员,为了要容纳k(20个字节),就必须要保证是8的倍数的同时还要大于20个字节,所以是24个字节
```

+ **位域**
    - C语言允许在一个结构体中以位为单位来指定其成员所占内存长度，这种以位为单位的成员称为“位段”或 称“位域”( bit field) 。
    - 利用位段能够用较少的位数存储数据。一个位段必须存储在同一存储单元中，不能跨两个单元。如果第一个单元空间不能容纳下一个位段，则该空间不用，而从下一个单元起存放该位段。
    - 特点：  
1.位段声明和结构体类似  
2.位段的成员必须是int、unsigned int、signed int  
3.位段的成员名后边有一个冒号和一个数字

```cpp
typedef struct_data{
	char m:3;
	char n:5;
	short s;
	
	union{
	int a;
	char b;
	};
	
	int h;
}_attribute_((packed)) data_t;
//12
```

###### 11、inline函数
+ 在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。为了解决这个问题，特别的引入了inline修饰符，表示为内联函数。
+ 大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline放在函数定义(注意是定义而非声明)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开。
+ 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。
+ 和define差不多，区别是一个是在预处理阶段，一个是在编译阶段

###### 12、内存四区，什么变量分别存储在什么区域，堆上还是栈上。
![](/images/a904d4c981668ec8443996b2e1ee918a.png)

```cpp
int a0=1;
static int a1;
const static a2=0;
extern int a3;
void fun(void)
{
	int a4;
	volatile int a5;
	return ;
}
```

+ 文字常量区，叫.rodata，不可以改变，改变会导致段错误
+ a0 ：全局初始化变量；生命周期为整个程序运行期间；作用域为所有文件；存储位置为data段
+ a1 ：全局静态未初始化变量；生命周期为整个程序运行期间；作用域为当前文件；储存位置为BSS段。
+ a2 ：全局静态变量
+ a3 ：全局初始化变量；其他同a0
+ a4 ：局部变量；生命周期为fun函数运行期间；作用域为fun函数内部；储存位置为栈。
+ a5 ：局部易变变量；

###### 13、使用32位编译情况下，给出判断所使用机器大小端的方法。
![](/images/aaca0aa20bd1dd3db6f12be513cdca5c.png)![](/images/81c871c9282fc01e192a2b9f2673bfd7.png)

+ 联合体方法判断方法：利用union结构体的从低地址开始存，且同一时间内只有一个成员占有内存的特性。大端储存符合阅读习惯。联合体占用内存是最大的那个，和结构体不一样。
+ a和c公用同一片内存区域，所以更改c，必然会影响a的数据

```cpp
#include <stdio.h> 
union w{
	int a;
	char b;
}c;
int main()
{
	c.a=1;
	if(c.b==1)
		print("低位字节在低地址存储，小端")
	else
		print("低位字节在高地址存储，大端")
	return 0;
}
```

+ 指针方法： 
    - 通过将int强制类型转换成char单字节，p指向a的起始字节（低字节）

```cpp
#include <stdio.h>
int main()
{
	int a=1;
	char* p=(char *)&a;//四字节地址换成2字节地址，看看最后2字节地址保留四字节的左边还是右边
	if(*p==1)
		printf("小端存储\n")
	else
		printf("大端存储\n")
	return 0;
}
```

###### 14、用变量a给出下面的定义
```cpp
int a;//一个整型数；
int* a;//一个指向整型数的指针；
int** a;//一个指向指针的指针，它指向的指针是指向一个整型数；

int a[10];//一个有10个整型的数组；
int* a[10];//指针数组，是个数组，里面的10个元素为指针
int (*a)[10];//数组指针，是个指针，指向10个元素

int* a(int);//指针函数，是个函数，返回值为指针
int (*a)(int);//函数指针，是个指针。，指向函数的指针
int(*a[10](int));//一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数
```

###### 15、与或非，异或。运算符优先级
![](/images/0c24061f15565f748535a9192ac6f167.png)

+ 优先级： ! > 算术 > 关系 > 逻辑 > 条件 > 赋值 > 逗号

参考链接：https://blog.csdn.net/start_mao/article/details/111085064  
参考链接：https://blog.csdn.net/weixin_49001854/article/details/108816412  
参考链接：https://blog.csdn.net/m0_51167384/article/details/115472319  
参考链接：https://blog.csdn.net/weixin_41685207  
参考连接：https://zhidao.baidu.com/question/544114274.html  
参考链接：https://blog.csdn.net/weixin_47397155/article/details/117742128  
参考链接：https://blog.csdn.net/weixin_47397155/article/details/117954369  
参考链接：https://blog.csdn.net/mick_hu/article/details/100931034  
参考链接：https://blog.csdn.net/The_Jinz/article/details/121801144  


> 来自: [c/c++常识（八股文篇）_c++八股文-CSDN博客](https://blog.csdn.net/weixin_47397155/article/details/125355240?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-125355240-blog-125937918.235%5Ev43%5Epc_blog_bottom_relevance_base5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-125355240-blog-125937918.235%5Ev43%5Epc_blog_bottom_relevance_base5&utm_relevant_index=2)
>

