---
title: 面试官爱问，命中率最高，100道C++面试题，全面总结分析
date: '2025-02-08 13:22:08'
updated: '2025-02-08 13:22:09'
---
![](/images/b20ab0fee4aa2ba69113be4e5384ab88.png)

**<font style="color:rgba(0, 0, 0, 0.9);">一：编程语言基础</font>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">1：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">根据熟悉的语言，谈谈两种语言的区别？</font></u>**

<u><font style="color:rgba(0, 0, 0, 0.9);">主要浅谈下C/C++和PHP语言的区别:</font></u>

+ <font style="color:rgba(0, 0, 0, 0.9);">1)PHP弱类型语言，一种脚本语言，对数据的类型不要求过多，较多的应用于Web应用开发，现在好多互联网开发公司的主流web后台开发语言，主要框架为mvc模型，如smarty,yaf，升级的PHP7速度较快，对服务器的压力要小很多，在新浪微博已经有应用，对比很明显。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2)C/C++开发语言，C语言更偏向硬件底层开发，C++语言是目前为止我认为语法内容最多的一种语言。C/C++在执行速度上要快很多，毕竟其他类型的语言大都是C开发的，更多应用于网络编程和嵌入式编程。 </font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">2：volatile</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">是干啥用的，（必须将</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">cpu</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的寄存器缓存机制回答的很透彻），使用实例有哪些？（重点）</font></u>**

+ **<font style="color:rgba(0, 0, 0, 0.9);">1</font>**<font style="color:rgba(0, 0, 0, 0.9);">访问寄存器比访问内存单元要快,编译器会优化减少内存的读取，可能会读脏数据。声明变量为volatile，编译器不再对访问该变量的代码优化，仍然从内存读取，使访问稳定。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2总结：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不再编译优化，以免出错。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);">3</font>****<font style="color:rgba(0, 0, 0, 0.9);">使用实例如下(</font>**<font style="color:rgba(0, 0, 0, 0.9);">区分C程序员和嵌入式系统程序员的最基本的问题。</font>**<font style="color:rgba(0, 0, 0, 0.9);">)</font>****<font style="color:rgba(0, 0, 0, 0.9);">：</font>**
+ <font style="color:rgba(0, 0, 0, 0.9);">并行设备的硬件寄存器（如：状态寄存器）</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">多线程应用中被几个任务共享的变量</font><font style="color:rgb(51, 51, 51);">  
</font>**<font style="color:rgba(0, 0, 0, 0.9);">4</font>****<font style="color:rgba(0, 0, 0, 0.9);">一个参数既可以是const</font>****<font style="color:rgba(0, 0, 0, 0.9);">还可以是volatile</font>****<font style="color:rgba(0, 0, 0, 0.9);">吗？解释为什么。</font>**
+ <font style="color:rgba(0, 0, 0, 0.9);">可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</font><font style="color:rgb(51, 51, 51);">  
</font>**<font style="color:rgba(0, 0, 0, 0.9);">5</font>****<font style="color:rgba(0, 0, 0, 0.9);">一个指针可以是volatile </font>****<font style="color:rgba(0, 0, 0, 0.9);">吗？解释为什么。</font>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">可以。尽管这并不很常见。一个例子当中断服务子程序修该一个指向一个buffer的指针时。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">下面的函数有什么错误：</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">int square(volatile int *ptr) {</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">return *ptr * *ptr;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">}</font><font style="color:rgb(51, 51, 51);">  
</font>**<u><font style="color:rgba(0, 0, 0, 0.9);">下面是答案：</font></u>**<font style="color:rgb(51, 51, 51);">  
</font>**<u><font style="color:rgba(0, 0, 0, 0.9);">这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">int square(volatile int *ptr){</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">int a,b;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">a = *ptr;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">b = *ptr;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">return a * b;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">}</font><font style="color:rgb(51, 51, 51);">  
</font>**<u><font style="color:rgba(0, 0, 0, 0.9);">由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">long square(volatile int *ptr){</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">int a;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">a = *ptr;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">return a * a;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">}</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">3:static const</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">等等的用法，（能说出越多越好）（重点）</font></u>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">首先说说const</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的用法（绝对不能说是常数）</font></u>**

+ <font style="color:rgba(0, 0, 0, 0.9);">1）在定义的时候必须进行初始化</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2）指针可以是const  指针，也可以是指向const对象的指针</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">3）定义为const的形参，即在函数内部是不能被修改的</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">4）类的成员函数可以被声明为常成员函数，不能修改类的成员变量</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">5）类的成员函数可以返回的是常对象，即被const声明的对象</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">6）类的成员变量是常成员变量不能在声明时初始化，必须在构造函数的列表里进行初始化</font>

<font style="color:rgba(0, 0, 0, 0.9);">（注：千万不要说const是个常数，会被认为是外行人的！！！！哪怕说个只读也行）</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">下面的声明都是什么意思？</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">const int a; a是一个常整型数</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">int const a; a是一个常整型数</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">const int *a; a是一个指向常整型数的指针，整型数是不可修改的，但指针可以</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">int * const a; a为指向整型数的常指针，指针指向的整型数可以修改，但指针是不可修改的</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">int const * a const; a是一个指向常整型数的常指针，指针指向的整型数是不可修改的，同时指针也是不可修改的</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">const如何做到只读？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">这些在编译期间完成，对于内置类型，如int， 编译器可能使用常数直接替换掉对此变量的引用。而对于结构体不一定。 </font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">再说说static</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的用法（三个明显的作用一定要答出来）</font></u>**

+ **<font style="color:rgba(0, 0, 0, 0.9);">1</font>****<font style="color:rgba(0, 0, 0, 0.9);">）在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</font>**<font style="color:rgb(51, 51, 51);">  
</font>**<font style="color:rgba(0, 0, 0, 0.9);">2</font>****<font style="color:rgba(0, 0, 0, 0.9);">）在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</font>**<font style="color:rgb(51, 51, 51);">  
</font>**<font style="color:rgba(0, 0, 0, 0.9);">3</font>****<font style="color:rgba(0, 0, 0, 0.9);">）在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用</font>**
+ <font style="color:rgba(0, 0, 0, 0.9);">4）类内的static成员变量属于整个类所拥有，不能在类内进行定义，只能在类的作用域内进行定义</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">5）类内的static成员函数属于整个类所拥有，不能包含this指针，只能调用static成员函数</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">static</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">全局变量与普通的全局变量有什么区别</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">?static</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">局部变量和普通局部</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">变量有什么区别</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">?static</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">函数与普通函数有什么区别</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">?</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 </font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">4：extern c </font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">作用</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">告诉编译器该段代码以C语言进行编译。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">5：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">指针和引用的区别</font></u>**

+ <font style="color:rgba(0, 0, 0, 0.9);">1）引用是直接访问，指针是间接访问。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2）引用是变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">3）引用绑定内存空间（必须赋初值），是一个变量别名不能更改绑定，可以改变对象的值。</font>

<font style="color:rgba(0, 0, 0, 0.9);">总的来说：引用既具有指针的效率，又具有变量使用的方便性和直观性</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">6：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">关于静态内存分配和动态内存分配的区别及过程</font></u>**

+ <font style="color:rgba(0, 0, 0, 0.9);">1) 静态内存分配是在编译时完成的，不占用CPU资源；动态分配内存运行时完成，分配与释放需要占用CPU资源；</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2)静态内存分配是在栈上分配的，动态内存是堆上分配的；</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">3)动态内存分配需要指针或引用数据类型的支持，而静态内存分配不需要；</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">4)静态内存分配是按计划分配，在编译前确定内存块的大小，动态内存分配运行时按需分配。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">5)静态分配内存是把内存的控制权交给了编译器，动态内存把内存的控制权交给了程序员；</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">6)静态分配内存的运行效率要比动态分配内存的效率要高，因为动态内存分配与释放需要额外的开销；动态内存管理水平严重依赖于程序员的水平，处理不当容易造成内存泄漏。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">7：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">头文件中的</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);"> ifndef/define/endif </font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">干什么用</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">预处理，防止头文件被重复使用，包括pragma once都是这样的</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">8：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">宏定义求两个元素的最小值</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">#define MIN(A,B) （（A） <= (B) ? (A) : (B))</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">9：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">分别设置和清除一个整数的第三位？</font></u>**

```plain
#define BIT3 (0x1<<3)
static int a;
void set_bit3(void){ 
    a |= BIT3;
} 
void clear_bit3(void){ 
    a &= ~BIT3;
}
```

**<u><font style="color:rgba(0, 0, 0, 0.9);">10：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">用预处理指令</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">#define </font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">声明一个常数，用以表明</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">1</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">年中有多少秒</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">11：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">预处理器标识</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">#error</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的目的是什么？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">抛出错误提示，标识外部宏是否被定义!</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">12：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">嵌入式系统中经常要用到无限循环，你怎么样用</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">C</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">编写死循环呢？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">记住这是第一方案！！！！</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">while(1)</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">{</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">}</font>

<font style="color:rgba(0, 0, 0, 0.9);">一些程序员更喜欢如下方案：</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">for(;;){</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">}</font>

<font style="color:rgba(0, 0, 0, 0.9);">汇编语言的无线循环是：</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">Loop:</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">...</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">goto Loop;</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">13：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">用变量</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">a</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">给出下面的定义</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数 int (*a[10])(int);</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">14：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">—</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">让标准</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">C</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">支持中断。</font></u>**

**<font style="color:rgba(0, 0, 0, 0.9);">具代表事实是，产生了一个新的关键字</font>****<font style="color:rgba(0, 0, 0, 0.9);"> __interrupt</font>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">16：memcpy</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">函数的实现</font></u>**

```plain
void *memcpy(void *dest, const void *src, size_t count) {
 char *tmp = dest;
 const char *s = src;
 
 while (count--)
  *tmp++ = *s++;
  return dest;
}
```

**<u><font style="color:rgba(0, 0, 0, 0.9);">17：Strcpy</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">函数实现</font></u>**

```plain
char *strcpy(char *dst,const char *src) { 
      assert(dst != NULL && src != NULL); 
      char *ret = dst; 
      while((* dst++ = * src++) != '\0') ; 
      return ret; 
 }
```

**<u><font style="color:rgb(51, 51, 51);">18：strcat</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">函数的实现</font></u>**

```plain
char *strcat(char *strDes, const char *strSrc){
assert((strDes != NULL) && (strSrc != NULL));
char *address = strDes;
while (*strDes != ‘\0′)
++ strDes;
while ((*strDes ++ = *strSrc ++) != ‘\0′)
return address;
}
```

**<u><font style="color:rgb(51, 51, 51);">19：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">strncat</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">实现</font></u>**

```plain
char *strncat(char *strDes, const char *strSrc, int count){
assert((strDes != NULL) && (strSrc != NULL));
char *address = strDes;
while (*strDes != ‘\0′)
++ strDes;
while (count — && *strSrc != ‘\0′ )
*strDes ++ = *strSrc ++;
*strDes = ‘\0′;
return address;
}
```

**<u><font style="color:rgb(51, 51, 51);">20：strcmp</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">函数实现</font></u>**

```plain
int strcmp(const char *str1,const char *str2){
    /*不可用while(*str1++==*str2++)来比较，当不相等时仍会执行一次++，
    return返回的比较值实际上是下一个字符。应将++放到循环体中进行。*/
    while(*str1 == *str2){
        if(*str1 == '\0')
            return0;
         
        ++str1;
        ++str2;
    }
    return *str1 - *str2;
}
```

**<u><font style="color:rgb(51, 51, 51);">21：strncmp</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">实现</font></u>**

```plain
int strncmp(const char *s, const char *t, int count){
    assert((s != NULL) && (t != NULL));
    while (*s && *t && *s == *t && count –) {
        ++ s;
        ++ t;
    }
    return (*s – *t);
}
```

**<u><font style="color:rgb(51, 51, 51);">22：strlen</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">函数实现</font></u>**

```plain
int strlen(const char *str){
    assert(str != NULL);
    int len = 0;
    while (*str ++ != ‘\0′)
        ++ len;
    return len;
}
```

**<u><font style="color:rgb(51, 51, 51);">23：strpbrk</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">函数实现</font></u>**

```plain
char * strpbrk(const char * cs,const char * ct){
    const char *sc1,*sc2;
    for( sc1 = cs; *sc1 != '\0'; ++sc1){
        for( sc2 = ct; *sc2 != '\0'; ++sc2){
            if (*sc1 == *sc2){
                return (char *) sc1;
            }
        }
    }
    return NULL;
}
```

**<u><font style="color:rgb(51, 51, 51);">24：strstr</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">函数实现</font></u>**

```plain
char *strstr(const char *s1,const char *s2){
　int len2;
　if(!(len2=strlen(s2)))//此种情况下s2不能指向空，否则strlen无法测出长度，这条语句错误
　 return(char*)s1;
　for(;*s1;++s1)
　{
    　if(*s1==*s2 && strncmp(s1,s2,len2)==0)
    　return(char*)s1;
　}
　return NULL;
}
```

**<u><font style="color:rgb(51, 51, 51);">25：string</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">实现（注意：赋值构造，</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">operator=</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">是关键</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">）</font></u>**

```plain
class String{
public:
//普通构造函数
String(const char *str = NULL);
//拷贝构造函数
String(const String &other);
//赋值函数
String & operator=(String &other) ;
//析构函数
~String(void);
private:
char* m_str;
};
```

**<u><font style="color:rgba(0, 0, 0, 0.9);">分别实现以上四个函数</font></u>**

```plain
//普通构造函数
String::String(const char* str){
    if(str==NULL) //如果str为NULL，存空字符串{
        m_str = new char[1]; //分配一个字节
        *m_str = ‘\0′; //赋一个’\0′
}else{
       str = new char[strlen(str) + 1];//分配空间容纳str内容
        strcpy(m_str, str); //复制str到私有成员m_str中
    }
}
```

```plain
//析构函数
String::~String(){
 
    if(m_str!=NULL) //如果m_str不为NULL，释放堆内存{
        delete [] m_str;
        m_str = NULL;
}
}
```

```plain
//拷贝构造函数
String::String(const String &other){
    m_str = new char[strlen(other.m_str)+1]; //分配空间容纳str内容
    strcpy(m_str, other.m_str); //复制other.m_str到私有成员m_str中 
}
```

```plain
//赋值函数
String & String::operator=(String &other){
    if(this == &other) //若对象与other是同一个对象，直接返回本{
        return *this
}
    delete [] m_str; //否则，先释放当前对象堆内存
    m_str = new char[strlen(other.m_str)+1]; //分配空间容纳str内容
    strcpy(m_str, other.m_str); //复制other.m_str到私有成员m_str中
    return *this；
}
```

**<u><font style="color:rgba(0, 0, 0, 0.9);">26：C</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">语言同意一些令人震惊的结构</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">,</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">下面的结构是合法的吗，如果是它做些什么？</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">int a = 5, b = 7, c;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">c = a+++b; 等同于 c = a++ + b;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">因此, 这段代码持行后a = 6, b = 7, c = 12。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">27：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">用</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">struct</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">关键字与</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">class</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">关键定义类以及继承的区别</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">（1）定义类差别</font>

<font style="color:rgba(0, 0, 0, 0.9);">struct关键字也可以实现类，用class和struct关键字定义类的唯一差别在于默认访问级别：默认情况下，struct成员的访问级别为public，而class成员的为private。语法使用也相同，直接将class改为struct即可。</font>

<font style="color:rgba(0, 0, 0, 0.9);">（2）继承差别</font>

<font style="color:rgba(0, 0, 0, 0.9);">使用class保留字的派生类默认具有private继承，而用struct保留字定义的类某人具有public继承。其它则没有任何区别。</font>

<font style="color:rgba(0, 0, 0, 0.9);">主要点就两个：默认的访问级别和默认的继承级别 class都是private</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">28：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">派生类与虚函数概述</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">(1) 派生类继承的函数不能定义为虚函数。虚函数是希望派生类重新定义。如果派生类没有重新定义某个虚函数，则在调用的时候会使用基类中定义的版本。</font>

<font style="color:rgba(0, 0, 0, 0.9);">(2)派生类中函数的声明必须与基类中定义的方式完全匹配。</font>

<font style="color:rgba(0, 0, 0, 0.9);">(3) 基类中声明为虚函数，则派生类也为虚函数。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">29：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">虚函数与纯虚函数区别</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1）虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现</font>

<font style="color:rgba(0, 0, 0, 0.9);">2）带纯虚函数的类叫虚基类也叫抽象类，这种基类不能直接生成对象，只能被继承，重写虚函数后才能使用，运行时动态动态绑定！</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">30：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">深拷贝与浅拷贝</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">浅拷贝：</font>

```plain
char ori[]=“hello”；char *copy=ori；
```

<font style="color:rgba(0, 0, 0, 0.9);">深拷贝：</font>

```plain
char ori[]="hello";  char *copy=new char[];  copy=ori;
```

<font style="color:rgba(0, 0, 0, 0.9);">浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。</font>

<font style="color:rgba(0, 0, 0, 0.9);">浅拷贝可能出现的问题：</font>

<font style="color:rgba(0, 0, 0, 0.9);">1） 浅拷贝只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构2次，即delete同一块内存2次，造成程序崩溃。</font>

<font style="color:rgba(0, 0, 0, 0.9);">2） 浅拷贝使得两个指针都指向同一块内存，任何一方的变动都会影响到另一方。</font>

<font style="color:rgba(0, 0, 0, 0.9);">3） 同一个空间，第二次释放失败，导致无法操作该空间，造成内存泄漏。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">31：stl</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">各容器的实现原理（必考）</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1) Vector顺序容器，是一个动态数组，支持随机插入、删除、查找等操作，在内存中是一块连续的空间。在原有空间不够情况下自动分配空间，增加为原来的两倍。vector随机存取效率高，但是在vector插入元素，需要移动的数目多，效率低下。</font>

<font style="color:rgba(0, 0, 0, 0.9);">注：vector动态增加大小时是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector空间重新配置，指向原vector的所有迭代器就都失效了。</font>

<font style="color:rgba(0, 0, 0, 0.9);">2) Map关联容器，以键值对的形式进行存储，方便进行查找。关键词起到索引的作用，值则表示与索引相关联的数据。红黑树的结构实现，插入删除等操作都在O(logn)时间内完成。</font>

<font style="color:rgba(0, 0, 0, 0.9);">3) Set是关联容器，set每个元素只包含一个关键字。set支持高效的关键字检查是否在set中。set也是以红黑树的结构实现，支持高效插入、删除等操作。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">32：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">哪些库函数属于高危函数，为什么？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">strcpy 赋值到目标区间可能会造成缓冲区溢出！</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">33：STL</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">有</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">7</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">种主要容器：</font></u>****<font style="color:rgba(0, 0, 0, 0.9);">vector,list,deque,map,multimap,set,multiset</font>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">34：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">你如何理解</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">MVC</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">。简单举例来说明其应用。</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">MVC模式是observer 模式的一个特例,现在很多都是java的一些框架，MFC的，PHP的。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">35：C++</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">特点是什么，多态实现机制？（面试问过）多态作用？两个必要条件？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">C++中多态机制主要体现在两个方面，一个是函数的重载，一个是接口的重写。接口多态指的是“一个接口多种形态”。每一个对象内部都有一个虚表指针，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。</font>

<font style="color:rgba(0, 0, 0, 0.9);">多态的基础是继承，需要虚函数的支持，简单的多态是很简单的。子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等</font>

**<font style="color:rgba(0, 0, 0, 0.9);">作用：</font>**

<font style="color:rgba(0, 0, 0, 0.9);">1.隐藏实现细节，代码能够模块化；</font>

<font style="color:rgba(0, 0, 0, 0.9);">2.接口重用：为了类在继承和派生的时候正确调用。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">必要条件：</font>**

<font style="color:rgba(0, 0, 0, 0.9);">1.一个基类的指针或者引用指向派生类的对象；</font>

<font style="color:rgba(0, 0, 0, 0.9);">2.虚函数</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">36：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">多重继承有什么问题</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">? </font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">怎样消除多重继承中的二义性</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">?</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1)增加程序的复杂度，使程序的编写和维护比较困难，容易出错；</font>

<font style="color:rgba(0, 0, 0, 0.9);">2)继承类和基类的同名函数产生了二义性，同名函数不知道调用基类还是继承类，C++中使用虚函数解决这个问题</font>

<font style="color:rgba(0, 0, 0, 0.9);">3)继承过程中可能会继承一些不必要的数据，对于多级继承，可能会产生数据很长</font>

<font style="color:rgba(0, 0, 0, 0.9);">可以使用成员限定符和虚函数解决多重继承中函数的二义性问题。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">37：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">求两个数的乘积和商数，该作用由宏定义来实现</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">#define product(a,b) ((a)*(b))</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">#define divide(a,b)  ((a)/(b))</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">38：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">什么叫静态关联，什么叫动态关联</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">多态中，静态关联是程序在编译阶段就能确定实际执行动作，程序运行才能确定叫动态关联</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">39：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">什么叫智能指针</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">?</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">常用的智能指针有哪些？智能指针的实现？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">智能指针是一个存储指向动态分配（堆）对象指针的类，构造函数传入普通指针，析构函数释放指针。栈上分配，函数或程序结束自动释放，防止内存泄露。使用引用计数器，类与指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建，增加引用计数；对一个对象进行赋值时，减少引用计数，并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数，当引用计数减至0，则删除基础对象。</font>

<font style="color:rgba(0, 0, 0, 0.9);">std::auto_ptr，不支持复制（拷贝构造函数）和赋值（operator =），编译不会提示出错。</font>

<font style="color:rgba(0, 0, 0, 0.9);">C++</font><font style="color:rgba(0, 0, 0, 0.9);">11引入的unique_ptr， 也不支持复制和赋值，但比auto_ptr好，直接赋值会编译出错。</font>

<font style="color:rgba(0, 0, 0, 0.9);">C++11或boost的shared_ptr，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。还有Weak_ptr</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">40：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">枚举与</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">#define </font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">宏的区别</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1）#define 宏常量是在预编译阶段进行简单替换。枚举常量则是在编译的时候确定其值。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">2）可以调试枚举常量，但是不能调试宏常量。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">3）枚举可以一次定义大量相关的常量，而#define 宏一次只能定义一个。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">41：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">介绍一下函数的重载</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">重载是在不同类型上作不同运算而又用同样的名字的函数。重载函数至少在参数个数，参数类型， 或参数顺序上有所不同。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">42：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">派生新类的过程要经历三个步骤</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1.吸收基类成员    2.改造基类成员    3.添加新成员</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">43：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">面向对象的三个基本特征，并简单叙述之</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">?</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1)封装：将客观事物抽象成类，每个类对自身的数据和方法实行2)继承3)多态：允许一个基类的指针或引用指向一个派生类对象</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">44：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">多态性体现都有哪些？动态绑定怎么实现？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">多态性是一个接口,多种实现，是面向对象的核心。 编译时多态性：通过重载函数实现。运行时多态性：通过虚函数实现,结合动态绑定。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">45：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">虚函数，虚函数表里面内存如何分配？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">编译时若基类中有虚函数，编译器为该的类创建一个一维数组的虚表，存放是每个虚函数的地址。基类和派生类都包含虚函数时，这两个类都建立一个虚表。构造函数中进行虚表的创建和虚表指针的初始化。在构造子类对象时，要先调用父类的构造函数，初始化父类对象的虚表指针，该虚表指针指向父类的虚表。执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。每一个类都有虚表。虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。当用一个指针/引用调用一个函数的时候，被调用的函数是取决于这个指针/引用的类型。即如果这个指针/引用是基类对象的指针/引用就调用基类的方法；如果指针/引用是派生类对象的指针/引用就调用派生类的方法，当然如果派生类中没有此方法，就会向上到基类里面去寻找相应的方法。这些调用在编译阶段就确定了。当涉及到多态性的时候，采用了虚函数和动态绑定，此时的调用就不会在编译时候确定而是在运行时确定。不在单独考虑指针/引用的类型而是看指针/引用的对象的类型来判断函数的调用，根据对象中虚指针指向的虚表中的函数的地址来确定调用哪个函数。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">46：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">纯虚函数如何定义？含有纯虚函数的类称为什么？为什么析构函数要定义成虚函数？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。纯虚函数是虚函数再加上= 0。virtual void fun ()=0。含有纯虚函数的类称为抽象类在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。如果析构函数不是虚函数，那么释放内存时候，编译器会使用静态联编，认为p就是一个基类指针，调用基类析构函数，这样子类对象的内存没有释放，造成内存泄漏。定义成虚函数以后，就会动态联编，先调用子类析构函数，再基类。</font><font style="color:rgb(51, 51, 51);">  
</font>**<u><font style="color:rgba(0, 0, 0, 0.9);">47：C++</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">中哪些不能是虚函数？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1）普通函数只能重载，不能被重写，因此编译器会在编译时绑定函数。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">2）构造函数是知道全部信息才能创建对象，然而虚函数允许只知道部分信息。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">3）内联函数在编译时被展开，虚函数在运行时才能动态绑定函数。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">4）友元函数 因为不可以被继承。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">5）静态成员函数 只有一个实体，不能被继承。父类和子类共有。</font><font style="color:rgb(51, 51, 51);">  
</font>**<font style="color:rgba(0, 0, 0, 0.9);">48：</font>****<font style="color:rgba(0, 0, 0, 0.9);">类型转换有哪些？各适用什么环境？</font>****<font style="color:rgba(0, 0, 0, 0.9);">dynamic_cast</font>****<font style="color:rgba(0, 0, 0, 0.9);">转换失败时，会出现什么情况</font>****<font style="color:rgba(0, 0, 0, 0.9);">(</font>****<font style="color:rgba(0, 0, 0, 0.9);">对指针，返回</font>****<font style="color:rgba(0, 0, 0, 0.9);">NULL.</font>****<font style="color:rgba(0, 0, 0, 0.9);">对引用，抛出</font>****<font style="color:rgba(0, 0, 0, 0.9);">bad_cast</font>****<font style="color:rgba(0, 0, 0, 0.9);">异常</font>****<font style="color:rgba(0, 0, 0, 0.9);">)</font>****<font style="color:rgba(0, 0, 0, 0.9);">？</font>**

<font style="color:rgba(0, 0, 0, 0.9);">静态类型转换，static_cast，基本类型之间和具有继承关系的类型。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">例子A,double类型转换成int。B,将子类对象转换成基类对象。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">常量类型转换，const_cast, 去除指针变量的常量属性。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">无法将非指针的常量转换为普通变量。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">动态类型转换，dynamic_cast，运行时进行转换分析的，并非在编译时进行。dynamic_cast转换符只能用于含有虚函数的类。dynamic_cast用于类层次间的向上转换和向下转换，还可以用于类间的交叉转换。在类层次间进行向上转换，即子类转换为父类，此时完成的功能和static_cast是相同的，因为编译器默认向上转换总是安全的。向下转换时，dynamic_cast具有类型检查的功能，更加安全。类间的交叉转换指的是子类的多个父类之间指针或引用的转换。该函数只能在继承类对象的指针之间或引用之间进行类型转换，或者有虚函数的类。 </font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">49：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">如何判断一段程序是由</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">C </font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">编译程序还是由</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">C++</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">编译程序编译的？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">#ifdef __cplusplus</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">cout<<"C++";</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">#else</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">cout<<"c";</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">#endif</font>

**<font style="color:rgba(0, 0, 0, 0.9);">50：</font>****<font style="color:rgba(0, 0, 0, 0.9);">为什么要用</font>****<font style="color:rgba(0, 0, 0, 0.9);">static_cast</font>****<font style="color:rgba(0, 0, 0, 0.9);">转换而不用</font>****<font style="color:rgba(0, 0, 0, 0.9);">c</font>****<font style="color:rgba(0, 0, 0, 0.9);">语言</font>****<font style="color:rgba(0, 0, 0, 0.9);">中的转换？</font>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">Static_cast转换，它会检查类型看是否能转换，有类型安全检查。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">比如，这个在C++中合法，但是确实错误的。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">A* a= new A;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">B* b = (B*)a;</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">51：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">操作符重载（</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">+</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">操作符），具体如何去定义？</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">除了类属关系运算符”.”、成员指针运算符”.*”、作用域运算符”::”、sizeof运算符和三目运算符”?:”以外，C++中的所有运算符都可以重载。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);"><返回类型说明符> operator <运算符符号>(<参数表>){}</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">重载为类的成员函数和重载为类的非成员函数。参数个数会不同，应为this指针。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">52：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">内存对齐的原则？</font></u>****<u><font style="color:rgb(51, 51, 51);">  
</font></u>**<font style="color:rgba(0, 0, 0, 0.9);">A.结构体的大小为最大成员的整数倍。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">B.成员首地址的偏移量为其类型大小整数倍。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">53：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">内联函数与宏定义的区别？</font></u>****<u><font style="color:rgb(51, 51, 51);">  
</font></u>**<font style="color:rgba(0, 0, 0, 0.9);">内联函数是用来消除函数调用时的时间开销。频繁被调用的短小函数非常受益。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">A. 宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">B. 宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的</font><font style="color:rgb(51, 51, 51);">  
</font>**<u><font style="color:rgba(0, 0, 0, 0.9);">54：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">动态分配对象和静态分配对象的区别？</font></u>****<u><font style="color:rgb(51, 51, 51);">  
</font></u>**<font style="color:rgba(0, 0, 0, 0.9);">动态分配就是用运算符new来创建一个类的对象，在堆上分配内存。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">静态分配就是A a;这样来由编译器来创建一个对象，在栈上分配内存。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">55：explicit</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">是干什么用的</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);"> ?</font></u>****<font style="color:rgb(51, 51, 51);">  
</font>**<font style="color:rgba(0, 0, 0, 0.9);">构造器 ，可以阻止不应该允许的经过</font><font style="color:rgba(0, 0, 0, 0.9);">转换构造函数</font><font style="color:rgba(0, 0, 0, 0.9);">进行的隐式转换的发生。</font>**<font style="color:rgba(0, 0, 0, 0.9);">explicit</font>****<font style="color:rgba(0, 0, 0, 0.9);">是用来防止外部非正规的拷贝构造的，要想不存在传值的隐式转换问题。</font>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">56：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">内存溢出有那些因素？</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">(1) 使用非类型安全(non-type-safe)的语言如 C/C++ 等。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">(2) 以不可靠的方式存取或者复制内存缓冲区。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">(3) 编译器设置的内存缓冲区太靠近关键数据结构。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">57：new</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">与</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">malloc</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的区别，</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">delete</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">和</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">free</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的区别？</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">1.malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">2.new能够自动分配空间大小，malloc传入参数。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">3. new/delete能进行对对象进行构造和析构函数的调用进而对内存进行更加详细的工作，而malloc/free不能。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">既然new/delete的功能完全覆盖了malloc/free，为什么C++还保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">58：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">必须使用初始化列表初始化数据成员的情况</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">1.是对象的情况；</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">2.const修饰的类成员；</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">3.引用成员数据；</font>

<font style="color:rgba(0, 0, 0, 0.9);">类成员变量的初始化不是按照初始化表顺序被初始化，是按照在类中声明的顺序被初始化的。</font><font style="color:rgb(51, 51, 51);">  
</font>**<u><font style="color:rgba(0, 0, 0, 0.9);">59：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">深入谈谈堆和栈</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1).分配和管理方式不同 ：</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">堆是动态分配的，其空间的分配和释放都由程序员控制。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。静态分配由编译器完成，比如局部变量的分配。动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">2).产生碎片不同</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">3).生长方向不同</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);"> 栈是向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。</font><font style="color:rgb(51, 51, 51);">  
</font>**<u><font style="color:rgba(0, 0, 0, 0.9);">60：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">内存的静态分配和动态分配的区别？</font></u>****<u><font style="color:rgb(51, 51, 51);">  
</font></u>**<font style="color:rgba(0, 0, 0, 0.9);">时间不同。静态分配发生在程序编译和连接时。动态分配则发生在程序调入和执行时。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">空间不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。alloca，可以从栈里动态分配内存，不用担心内存泄露问题，当函数返回时，通过alloca申请的内存就会被自动释放掉。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">61：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">模版怎么实现？模版作用？</font></u>****<u><font style="color:rgb(51, 51, 51);">  
</font></u>**<font style="color:rgba(0, 0, 0, 0.9);">实现：template void swap(T& a, T& b){}</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">作用：将算法与具体对象分离，与类型无关，通用，节省精力</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">62：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">多重类构造和析构的顺序</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">记住析构函数的调用顺序与构造函数是相反的。</font><font style="color:rgb(51, 51, 51);">  
</font>**<u><font style="color:rgba(0, 0, 0, 0.9);">63：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">迭代器删除元素的会发生什么？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">迭代器失效</font>**<font style="color:rgb(51, 51, 51);">  
</font>****<u><font style="color:rgba(0, 0, 0, 0.9);">64：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">静态成员函数和数据成员有什么意义？</font></u>****<u><font style="color:rgb(51, 51, 51);">  
</font></u>**<font style="color:rgba(0, 0, 0, 0.9);">1）非静态数据成员，每个对象都有自己的拷贝。而静态数据成员被当作是类的成员，是该类的所有对象所共有的，在程序中只分配一次内存只有一份拷贝，所以对象都共享，值对每个对象都是一样的，它的值可以更新。</font>

<font style="color:rgba(0, 0, 0, 0.9);">2）静态数据成员存储在全局数据区，所以不能在类声明中定义，应该在类外定义。由于它不属于特定的类对象，在没有产生类对象时作用域就可见，即在没有产生类的实例时，我们就可以操作它。</font>

<font style="color:rgba(0, 0, 0, 0.9);">3）静态成员函数与静态数据成员一样，都是在类的内部实现，属于类定义的一部分。因为普通成员函数总是具体的属于具体对象的，每个有this指针。静态成员函数没有this指针，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数。静态成员之间可以互相访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</font>

<font style="color:rgba(0, 0, 0, 0.9);">4）非静态成员函数可以任意地访问静态成员函数和静态数据成员；</font>

<font style="color:rgba(0, 0, 0, 0.9);">5）没有this指针的额外开销，静态成员函数与类的全局函数相比，速度上会有少许的增长；</font>

<font style="color:rgba(0, 0, 0, 0.9);">6）调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指调用静态成员函数。</font>**<font style="color:rgb(51, 51, 51);">  
</font>****<u><font style="color:rgba(0, 0, 0, 0.9);">65：sizeof</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">一个类求大小（注意成员变量，函数，虚函数，继承等等对大小的影响）</font></u>**

### <font style="color:rgba(0, 0, 0, 0.9);">成员变量：类的成员变量是影响类大小的主要因素。每个成员变量都会占用一定的内存空间，具体大小取决于其类型。</font>
### <font style="color:rgba(0, 0, 0, 0.9);">成员变量：类的成员变量是影响类大小的主要因素。每个成员变量都会占用一定的内存空间，具体大小取决于其类型。</font>
### <font style="color:rgba(0, 0, 0, 0.9);">成员函数：成员函数不会直接影响类的大小。无论类中有多少个成员函数，</font>`<font style="color:rgba(0, 0, 0, 0.9);">sizeof</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 的结果都不会改变。</font>
### <font style="color:rgba(0, 0, 0, 0.9);">虚函数：虚函数会影响类的大小。如果一个类有虚函数，编译器会为该类生成一个虚函数表（vtable），并在类中添加一个指向虚函数表的指针（vptr）。这个指针通常占用4或8字节（取决于系统架构）。</font>
### <font style="color:rgba(0, 0, 0, 0.9);">继承：继承也会影响类的大小。派生类会包含基类的成员变量，并且如果基类有虚函数，派生类也会继承虚函数表和vptr。</font>
### <font style="color:rgba(0, 0, 0, 0.9);">多重继承：多重继承会进一步增加类的大小。每个基类都会贡献自己的成员变量和虚函数表指针。</font>
### <font style="color:rgba(0, 0, 0, 0.9);">空类：空类（没有成员变量和虚函数）的大小通常为1字节。这是因为每个对象都需要有唯一的地址，即使它是空的。</font>
```plain
成员变量是影响类大小的主要因素。
内存对齐会增加类的大小。
成员函数不影响类的大小。
虚函数会增加类的大小（由于 vptr）。
继承会增加类的大小，尤其是多重继承。
空类的大小通常为 1 字节。
```

**<font style="color:rgba(0, 0, 0, 0.9);">66：</font>****<font style="color:rgba(0, 0, 0, 0.9);">请用</font>****<font style="color:rgba(0, 0, 0, 0.9);">C/C++</font>****<font style="color:rgba(0, 0, 0, 0.9);">实现字符串反转（不调用库函数）</font>****<font style="color:rgba(0, 0, 0, 0.9);">”abc”</font>****<font style="color:rgba(0, 0, 0, 0.9);">类型的</font>**

```plain
char *reverse_str(char *str) {
    if(NULL == str) { //字符串为空直接返回
        return str;
    }
    char *begin;
    char *end;
    begin = end = str;
 
    while(*end != '\0') { //end指向字符串的末尾
        end++;
    }
    --end;
 
    char temp;
    while(begin < end) { //交换两个字符
        temp = *begin;
        *begin = *end;
        *end = temp;
        begin++;
        end--;
    }
    return str; //返回结果
}
```

**<u><font style="color:rgba(0, 0, 0, 0.9);">67：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">写一个函数，将字符串翻转，翻转方式如下：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">“I am a student”</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">反转成</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">“student a am I”</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">，不借助任何库函数</font></u>**

```plain
#include <iostream>


// 翻转字符串的辅助函数
void reverseString(char* str, int start, int end) {
    while (start < end) {
        char temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        start++;
        end--;
    }
}


// 主函数，翻转句子中的单词
void reverseSentence(char* str) {
    if (str == nullptr) return;


    int len = 0;
    while (str[len] != '\0') len++; // 计算字符串长度


    // 1. 翻转整个字符串
    reverseString(str, 0, len - 1);


    // 2. 翻转每个单词
    int start = 0;
    for (int i = 0; i <= len; i++) {
        if (str[i] == ' ' || str[i] == '\0') { // 遇到空格或字符串结束符
            reverseString(str, start, i - 1);  // 翻转单词
            start = i + 1;                     // 更新下一个单词的起始位置
        }
    }
}


int main() {
    char str[] = "I am a student";
    std::cout << "Original: " << str << std::endl;


    reverseSentence(str);
    std::cout << "Reversed: " << str << std::endl;


    return 0;
}
```

**<u><font style="color:rgba(0, 0, 0, 0.9);">68：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">C++标准指明析构函数不能、也不应该抛出异常。C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，析构函数已经变成了异常处理的一部分。</font>

<font style="color:rgba(0, 0, 0, 0.9);">1）如果析构函数抛出异常，则</font>**<font style="color:rgba(0, 0, 0, 0.9);">异常点之后的程序不会执行</font>**<font style="color:rgba(0, 0, 0, 0.9);">，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</font>

<font style="color:rgba(0, 0, 0, 0.9);">2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">69：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">一般如果构造函数中存在动态内存分配，则必须定义拷贝构造函数。否则，可能会导致两个对象成员指向同一地址，出现“指针悬挂问题”。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">70：100</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">万个</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">32</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">位整数，如何最快找到中位数。能保证每个数是唯一的，如何实现</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">O(N)</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">算法？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1).内存足够时：快排</font>

<font style="color:rgba(0, 0, 0, 0.9);">2).内存不足时：分桶法：化大为小，把所有数划分到各个小区间，把每个数映射到对应的区间里，对每个区间中数的个数进行计数，数一遍各个区间，看看中位数落在哪个区间，若够小，使用基于内存的算法，否则 继续划分</font>

71：OFFSETOF(s, m)的宏定义，s是结构类型，m是s的成员，求m在s中的偏移量。

<font style="color:rgba(0, 0, 0, 0.9);">#define OFFSETOF（s, m） size_t（&((s*)0)->m）</font>

72：C++虚函数是如何实现的？

<font style="color:rgba(0, 0, 0, 0.9);">使用虚函数表。 C++对象使用虚表， 如果是基类的实例，对应位置存放的是基类的函数指针；如果是继承类，对应位置存放的是继承类的函数指针（如果在继承类有实现）。所以 ，当使用基类指针调用对象方法时，也会根据具体的实例，调用到继承类的方法。 </font>

73：C++的虚函数有什么作用？

<font style="color:rgba(0, 0, 0, 0.9);">虚函数作用是实现多态，虚函数其实是实现封装，使得使用者不需要关心实现的细节。在很多设计模式中都是这样用法，例如Factory、Bridge、Strategy模式。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">74：MFC中CString是类型安全类吗，为什么？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">不是，其他数据类型转换到CString可以使用CString的成员函数Format来转换</font>

75：动态链接库的两种使用方法及特点？

<font style="color:rgba(0, 0, 0, 0.9);">1)载入时动态链接，模块非常明确调用某个导出函数，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向系统提供了载入DLL时所需的信息及DLL函数定位。 </font>

**<font style="color:rgba(0, 0, 0, 0.9);">2)</font>**<font style="color:rgba(0, 0, 0, 0.9);">运行时动态链接。 </font>

**<font style="color:rgba(0, 0, 0, 0.9);"></font>****<font style="color:rgba(0, 0, 0, 0.9);">二：服务器编程</font>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">1：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">多线程和多进程的区别（重点</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);"> </font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">必须从</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">cpu</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">调度，上下文切换，数据共享，多核</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">cup</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）！</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1）进程数据是分开的:共享复杂，需要用IPC，同步简单；多线程共享进程数据：共享简单，同步复杂</font>

<font style="color:rgba(0, 0, 0, 0.9);">2）进程创建销毁、切换复杂，速度慢 ；线程创建销毁、切换简单，速度快 </font>

<font style="color:rgba(0, 0, 0, 0.9);">3）进程占用内存多， CPU利用率低；线程占用内存少， CPU利用率高</font>

<font style="color:rgba(0, 0, 0, 0.9);">4）进程编程简单，调试简单；线程 编程复杂，调试复杂</font>

<font style="color:rgba(0, 0, 0, 0.9);">5）进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉</font>

<font style="color:rgba(0, 0, 0, 0.9);">6）进程适应于多核、多机分布；线程适用于多核</font>

<font style="color:rgba(0, 0, 0, 0.9);">线程所私有的：</font>

<font style="color:rgba(0, 0, 0, 0.9);">线程id、寄存器的值、栈、线程的优先级和调度策略、线程的私有数据、信号屏蔽字、errno变量、</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">2：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">多线程锁的种类有哪些？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">a.互斥锁（mutex）</font>

<font style="color:rgba(0, 0, 0, 0.9);">b.递归锁 </font>

<font style="color:rgba(0, 0, 0, 0.9);">c.自旋锁 </font>

<font style="color:rgba(0, 0, 0, 0.9);">d.读写锁</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">3：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">自旋锁和互斥锁的区别？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">当锁被其他线程占用时，其他线程并不是睡眠状态，而是不停的消耗CPU，获取锁；互斥锁则不然，保持睡眠，直到互斥锁被释放激活。</font>

<font style="color:rgba(0, 0, 0, 0.9);">自旋锁，递归调用容易造成死锁，对长时间才能获得到锁的情况，使用自旋锁容易造成CPU效率低，只有内核可抢占式或SMP情况下才真正需要自旋锁。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">4：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">进程间通信和线程间通信</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1）管道 </font>

<font style="color:rgba(0, 0, 0, 0.9);">2）消息队列 </font>

<font style="color:rgba(0, 0, 0, 0.9);">3)共享内存 </font>

<font style="color:rgba(0, 0, 0, 0.9);">4)信号量 </font>

<font style="color:rgba(0, 0, 0, 0.9);">5)套接字 </font>

<font style="color:rgba(0, 0, 0, 0.9);">6)条件变量</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">5：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">多线程程序架构，线程数量应该如何设置？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">应尽量和CPU核数相等或者为CPU核数+1的个数</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">6：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">什么是原子操作，</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">gcc</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">提供的原子操作原语，使用这些原语如何实现读写锁？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">7：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">网络编程设计模式，</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">reactor/proactor/</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">半同步半异步模式？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">reactor模式：同步阻塞I/O模式，注册对应读写事件处理器，等待事件发生进而调用事件处理器处理事件。 proactor模式：异步I/O模式。Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，Proactor模式中，应用程序不需要进行实际读写过程。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">Reactor是：</font>**

<font style="color:rgba(0, 0, 0, 0.9);">主线程往epoll内核上注册socket读事件，主线程调用epoll_wait等待socket上有数据可读，当socket上有数据可读的时候，主线程把socket可读事件放入请求队列。睡眠在请求队列上的某个工作线程被唤醒，处理客户请求，然后往epoll内核上注册socket写请求事件。主线程调用epoll_wait等待写请求事件，当有事件可写的时候，主线程把socket可写事件放入请求队列。睡眠在请求队列上的工作线程被唤醒，处理客户请求。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">Proactor:</font>**

<font style="color:rgba(0, 0, 0, 0.9);">主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读完成后如何通知应用程序，主线程继续处理其他逻辑，当socket上的数据被读入用户缓冲区后，通过信号告知应用程序数据已经可以使用。应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后调用aio_write函数向内核注册socket写完成事件，并告诉内核写缓冲区的位置，以及写完成时如何通知应用程序。主线程处理其他逻辑。当用户缓存区的数据被写入socket之后内核向应用程序发送一个信号，以通知应用程序数据已经发送完毕。应用程序预先定义的数据处理函数就会完成工作。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">半同步半异步模式：</font>**

<font style="color:rgba(0, 0, 0, 0.9);">上层的任务（如：数据库查询，文件传输）使用同步I/O模型，简化了编写并行程序的难度。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">而底层的任务（如网络控制器的中断处理）使用异步I/O模型，提供了执行效率。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">8：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">有一个计数器，多个线程都需要更新，会遇到什么问题，原因是什么，应该如何做？如何优化？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">有可能一个线程更新的数据已经被另外一个线程更新了，更新的数据就会出现异常，可以加锁，保证数据更新只会被一个线程完成。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">9：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">如果</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">select</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">返回可读，结果只读到</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">0</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">字节，什么情况？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">某个套接字集合中没有准备好，可能会select内存用FD_CLR清为0.</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">10：connect</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">可能会长时间阻塞，怎么解决</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">?</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1.使用定时器；（最常用也最有效的一种方法）</font>

<font style="color:rgba(0, 0, 0, 0.9);">2.采用非阻塞模式：设置非阻塞，返回之后用select检测状态。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">11：keepalive </font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">是什么东西？如何使用？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">keepalive，是在TCP中一个可以检测死连接的机制。</font>

<font style="color:rgba(0, 0, 0, 0.9);">1）.如果主机可达，对方就会响应ACK应答，就认为是存活的。</font>

<font style="color:rgba(0, 0, 0, 0.9);">2）.如果可达，但应用程序退出，对方就发RST应答，发送TCP撤消连接。</font>

<font style="color:rgba(0, 0, 0, 0.9);">3）.如果可达，但应用程序崩溃，对方就发FIN消息。</font>

<font style="color:rgba(0, 0, 0, 0.9);">4）.如果对方主机不响应ack, rst，继续发送直到超时，就撤消连接。默认二个小时。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">12：socket</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">什么情况下可读？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1.socket接收缓冲区中已经接收的数据的字节数大于等于socket接收缓冲区低潮限度的当前值;对这样的socket的读操作不会阻塞,并返回一个大于0的值(准备好读入的数据的字节数).</font>

<font style="color:rgba(0, 0, 0, 0.9);">2.连接的读一半关闭(即:接收到对方发过来的FIN的TCP连接),并且返回0; </font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);"> 3.socket收到了对方的connect请求已经完成的连接数为非0.这样的soocket处于可读状态；</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);"> 4.异常的情况下socket的读操作将不会阻塞,并且返回一个错误(-1)。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">13：udp</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">调用</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">connect</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">有什么作用？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1).因为UDP可以是一对一，多对一，一对多，或者多对多的通信，所以每次调用sendto()/recvfrom()时都必须指定目标IP和端口号。通过调用connect()建立一个端到端的连接，就可以和TCP一样使用send()/recv()传递数据，而不需要每次都指定目标IP和端口号。但是它和TCP不同的是它没有三次握手的过程。</font>

<font style="color:rgba(0, 0, 0, 0.9);">2).可以通过在已建立连接的UDP套接字上，调用connect()实现指定新的IP地址和端口号以及断开连接。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">14：socket</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">编程，如果</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">client</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">断电了，服务器如何快速知道？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">使用定时器（适合有数据流动的情况）；</font>

<font style="color:rgba(0, 0, 0, 0.9);">使用socket选项SO_KEEPALIVE（适合没有数据流动的情况）; </font>

<font style="color:rgba(0, 0, 0, 0.9);">1）自己编写心跳包程序,简单的说就是自己的程序加入一条线程,定时向对端发送数据包,查看是否有ACK,根据ACK的返回情况来管理连接。此方法比较通用,一般使用业务层心跳处理,灵活可控,但改变了现有的协议;</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">2）使用TCP的keepalive机制,UNIX网络编程不推荐使用SO_KEEPALIVE来做心）跳检测。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">keepalive原理:TCP内嵌有心跳包,以服务端为例,当server检测到超过一定时间(/proc/sys/net/ipv4/tcp_keepalive_time 7200 即2小时)没有数据传输,那么会向client端发送一个keepalive packet。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">三：Lliunx</font>****<font style="color:rgba(0, 0, 0, 0.9);">操作系统</font>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">1：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">熟练</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">netstat tcpdump ipcs ipcrm</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">netstat:检查网络状态，tcpdump:截获数据包，ipcs:检查共享内存，ipcrm:解除共享内存</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">2：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">将一块内存映射到两个或者多个进程地址空间。通过指针访问该共享内存区。一般通过mmap将文件映射到进程地址共享区。</font>

<font style="color:rgba(0, 0, 0, 0.9);">存在于进程数据段，最大限制是0x2000000Byte</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">3：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">进程内存空间分布情况</font></u>****<font style="color:rgba(0, 0, 0, 0.9);"> </font>**

<font style="color:rgb(64, 64, 64);">Linux 进程的内存空间通常分为以下几个主要区域：</font>

### **<font style="color:rgb(64, 64, 64);">a代码段（Text Segment）</font>**
+ **<font style="color:rgb(64, 64, 64);">存放内容</font>**<font style="color:rgb(64, 64, 64);">：程序的机器指令（即编译后的可执行代码）。</font>
+ **<font style="color:rgb(64, 64, 64);">特点</font>**<font style="color:rgb(64, 64, 64);">：</font>
    - <font style="color:rgb(64, 64, 64);">通常是只读的，防止程序意外修改指令。</font>
    - <font style="color:rgb(64, 64, 64);">在内存中只有一份，多个进程可以共享同一份代码段（例如多个实例运行同一个程序）。 </font>

### **<font style="color:rgb(64, 64, 64);">b数据段（Data Segment）</font>**
+ **<font style="color:rgb(64, 64, 64);">存放内容</font>**<font style="color:rgb(64, 64, 64);">：全局变量和静态变量。</font>
+ **<font style="color:rgb(64, 64, 64);">分为两部分</font>**<font style="color:rgb(64, 64, 64);">：</font>
    - <font style="color:rgb(64, 64, 64);">存放未初始化的全局变量和静态变量。</font>
    - <font style="color:rgb(64, 64, 64);">在程序加载时，操作系统会将其初始化为零。</font>
    - <font style="color:rgb(64, 64, 64);">存放已初始化的全局变量和静态变量。</font>
    1. **<font style="color:rgb(64, 64, 64);">已初始化数据段（Initialized Data Segment）</font>**<font style="color:rgb(64, 64, 64);">：</font>
    2. **<font style="color:rgb(64, 64, 64);">未初始化数据段（Uninitialized Data Segment，BSS）</font>**<font style="color:rgb(64, 64, 64);">：</font>

### **<font style="color:rgb(64, 64, 64);">c堆（Heap）</font>**
+ **<font style="color:rgb(64, 64, 64);">存放内容</font>**<font style="color:rgb(64, 64, 64);">：动态分配的内存（例如通过 </font>`<font style="color:rgb(64, 64, 64);">malloc</font>`<font style="color:rgb(64, 64, 64);">、</font>`<font style="color:rgb(64, 64, 64);">calloc</font>`<font style="color:rgb(64, 64, 64);">、</font>`<font style="color:rgb(64, 64, 64);">realloc</font>`<font style="color:rgb(64, 64, 64);"> 等函数分配的内存）。</font>
+ **<font style="color:rgb(64, 64, 64);">特点</font>**<font style="color:rgb(64, 64, 64);">：</font>
    - <font style="color:rgb(64, 64, 64);">堆的内存空间从低地址向高地址增长。</font>
    - <font style="color:rgb(64, 64, 64);">需要手动管理内存分配和释放（容易产生内存泄漏或碎片）。</font>

### **<font style="color:rgb(64, 64, 64);">d栈（Stack）</font>**
+ **<font style="color:rgb(64, 64, 64);">存放内容</font>**<font style="color:rgb(64, 64, 64);">：局部变量、函数参数、返回地址等。</font>
+ **<font style="color:rgb(64, 64, 64);">特点</font>**<font style="color:rgb(64, 64, 64);">：</font>
    - <font style="color:rgb(64, 64, 64);">栈的内存空间从高地址向低地址增长。</font>
    - <font style="color:rgb(64, 64, 64);">由编译器自动管理，无需手动分配和释放。</font>
    - <font style="color:rgb(64, 64, 64);">每个线程都有自己的栈。 </font>

### **<font style="color:rgb(64, 64, 64);">e内存映射区域（Memory Mapping Segment）</font>**
+ **<font style="color:rgb(64, 64, 64);">存放内容</font>**<font style="color:rgb(64, 64, 64);">：</font>
    - <font style="color:rgb(64, 64, 64);">动态链接库（共享库）。</font>
    - <font style="color:rgb(64, 64, 64);">文件映射（例如通过 </font>`<font style="color:rgb(64, 64, 64);">mmap</font>`<font style="color:rgb(64, 64, 64);"> 映射的文件）。</font>
+ **<font style="color:rgb(64, 64, 64);">特点</font>**<font style="color:rgb(64, 64, 64);">：</font>
    - <font style="color:rgb(64, 64, 64);">可以用于实现共享内存或高效的文件 I/O。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">ELF</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">是什么？其大小与程序中全局变量的是否初始化有什么关系（注意未初始化的数据放在</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">bss</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">段）</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">可执行连接格式。可以减少重新编程重新编译的代码。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">5：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">动态链接和静态链接的区别？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在可执行文件运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">6：32</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">位系统一个进程最多有多少堆内存</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">32位意味着4G的寻址空间，</font><font style="color:rgba(0, 0, 0, 0.9);">Linux</font><font style="color:rgba(0, 0, 0, 0.9);">把它分为两部分：最高的1G(虚拟地址从0xC0000000到0xffffffff)用做内核本身，成为“系统空间”，而较低的3G字节（从0x00000000到0xbffffff）用作各进程的“用户空间”。每个进程可以使用的用户空间是3G。虽然各个进程拥有其自己的3G用户空间，系统空间却由所有的进程共享。从具体进程的角度看，则每个进程都拥有4G的虚拟空间，较低的3G为自己的用户空间，最高的1G为所有进程以及内核共享的系统空间。实际上有人做过测试也就2G左右。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">7：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">写一个</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">c</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">程序辨别系统是</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">64</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">位</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);"> or 32</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">位</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);"></font>**<font style="color:rgba(0, 0, 0, 0.9);">void</font>**<font style="color:rgba(0, 0, 0, 0.9);">* number =  0;      printf("%d\n",</font>**<font style="color:rgba(0, 0, 0, 0.9);">sizeof</font>**<font style="color:rgba(0, 0, 0, 0.9);">(&number));  </font>

<font style="color:rgba(0, 0, 0, 0.9);">输出8就是64位 输出4就是32位的 根据逻辑地址判断的</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">8：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">写一个</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">c</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">程序辨别系统是大端</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">or</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">小端字节序</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">union{ short value; char a[sizeof(short)];}test;</font>

<font style="color:rgba(0, 0, 0, 0.9);">test.value= 0x0102;</font>

<font style="color:rgba(0, 0, 0, 0.9);">if((test.a[0] == 1) && (test.a[1] == 2)) cout << "big"<<endl; else cout << "little"  << endl;</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">9：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">信号：列出常见的信号，信号怎么处理？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1).进程终止的信号 2).跟踪进程的信号 3).与进程例外事件相关的信号等</font>

<font style="color:rgba(0, 0, 0, 0.9);">对于信号的处理或者执行相关的操作进行处理或者直接忽略</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">10：i++ </font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">是否原子操作</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">?</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">并解释为什么</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">?</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">答案肯定不是原子操作，i++主要看三个步骤</font>

<font style="color:rgba(0, 0, 0, 0.9);">首先把数据从内存放到寄存器上，在寄存器上进行自增处理，放回到寄存器上，每个步骤都可能会被中断分离开！</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">11：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">说出你所知道的各类</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">linux</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1).原子操作 2).信号量（其实就是互斥锁也就是锁的机制）3).读写信号量（就是读写锁） 4）.自旋锁  5.内核锁 6）.顺序锁</font>

<font style="color:rgba(0, 0, 0, 0.9);">死锁就是几个进程申请资源，出现了循环等待的情况！</font>

<font style="color:rgba(0, 0, 0, 0.9);">避免死锁的方法：</font>

<font style="color:rgba(0, 0, 0, 0.9);">1）资源是互斥的 </font>

<font style="color:rgba(0, 0, 0, 0.9);">2）不可抢占 </font>

<font style="color:rgba(0, 0, 0, 0.9);">3）占有且申请 </font>

<font style="color:rgba(0, 0, 0, 0.9);">4）循环等待</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">12</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">exit() _exit()的区别？</font></u>**

**<font style="color:rgb(64, 64, 64);">在Linux系统中，</font>**`**<font style="color:rgb(64, 64, 64);">exit()</font>**`**<font style="color:rgb(64, 64, 64);">和</font>**`**<font style="color:rgb(64, 64, 64);">_exit()</font>**`**<font style="color:rgb(64, 64, 64);">都是用于终止进程的函数，但它们的行为和用途有一些关键区别。</font>****<font style="color:rgba(0, 0, 0, 0.9);"> </font>**

**<font style="color:rgba(0, 0, 0, 0.9);">exit()：</font>**

1. **<font style="color:rgba(0, 0, 0, 0.9);">清理操作</font>****<font style="color:rgba(0, 0, 0, 0.9);">：</font>**
    - <font style="color:rgba(0, 0, 0, 0.9);">调用通过 </font>`<font style="color:rgba(0, 0, 0, 0.9);">atexit()</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 或 </font>`<font style="color:rgba(0, 0, 0, 0.9);">on_exit()</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 注册的函数。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">刷新所有打开的标准 I/O 流（如 </font>`<font style="color:rgba(0, 0, 0, 0.9);">stdout</font>`<font style="color:rgba(0, 0, 0, 0.9);">、</font>`<font style="color:rgba(0, 0, 0, 0.9);">stderr</font>`<font style="color:rgba(0, 0, 0, 0.9);">）。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">关闭所有打开的文件流。</font>
    - `<font style="color:rgba(0, 0, 0, 0.9);">exit()</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 是标准库函数，它会执行一些清理操作，包括：</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">这些清理操作确保程序退出时资源被正确释放。</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);">退出状态</font>****<font style="color:rgba(0, 0, 0, 0.9);">：</font>**
    - `<font style="color:rgba(0, 0, 0, 0.9);">status</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 参数是进程的退出状态，通常 </font>`<font style="color:rgba(0, 0, 0, 0.9);">0</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 表示成功，非零值表示错误。</font>
3. **<font style="color:rgba(0, 0, 0, 0.9);">使用场景</font>****<font style="color:rgba(0, 0, 0, 0.9);">：</font>**
    - <font style="color:rgba(0, 0, 0, 0.9);">适用于需要执行清理操作的场景，例如释放动态内存、关闭文件等。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">_exit()：</font>**

1. **<font style="color:rgba(0, 0, 0, 0.9);">直接终止进程</font>****<font style="color:rgba(0, 0, 0, 0.9);">：</font>**
    - `<font style="color:rgba(0, 0, 0, 0.9);">_exit()</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 是系统调用，它会立即终止进程，</font>**<font style="color:rgba(0, 0, 0, 0.9);">不会执行任何清理操作</font>**<font style="color:rgba(0, 0, 0, 0.9);">。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">不会刷新标准 I/O 缓冲区，也不会调用 </font>`<font style="color:rgba(0, 0, 0, 0.9);">atexit()</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 或 </font>`<font style="color:rgba(0, 0, 0, 0.9);">on_exit()</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 注册的函数。</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);">退出状态</font>****<font style="color:rgba(0, 0, 0, 0.9);">：</font>**
    - `<font style="color:rgba(0, 0, 0, 0.9);">status</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 参数是进程的退出状态，与 </font>`<font style="color:rgba(0, 0, 0, 0.9);">exit()</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 相同。</font>
3. **<font style="color:rgba(0, 0, 0, 0.9);">使用场景</font>****<font style="color:rgba(0, 0, 0, 0.9);">：</font>**
    - <font style="color:rgba(0, 0, 0, 0.9);">适用于需要立即终止进程的场景，例如在子进程中调用 </font>`<font style="color:rgba(0, 0, 0, 0.9);">_exit()</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 以避免重复执行父进程的清理操作。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">13</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">：如何实现守护进程？</font></u>**

+ <font style="color:rgba(0, 0, 0, 0.9);">1）创建子进程，父进程退出</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2）在子进程中创建新会话</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">3）改变当前目录为根目</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">4）重设文件权限掩码</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">5) 关闭文件描述符</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">6) 守护进程退出处理</font>

<font style="color:rgba(0, 0, 0, 0.9);">当用户需要外部停止守护进程运行时，往往会使用 kill命令停止该守护进程。所以，守护进程中需要编码来实现kill发出的signal信号处理，达到进程的正常退出。 </font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">14</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">linux</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的任务调度机制是什么？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">Linux</font><font style="color:rgba(0, 0, 0, 0.9);"> 分实时进程和普通进程，实时进程应该先于普通进程而运行。实时进程：</font>

<font style="color:rgba(0, 0, 0, 0.9);">1） FIFO(先来先服务调度)</font>

<font style="color:rgba(0, 0, 0, 0.9);">2） RR（时间片轮转调度）。</font>

<font style="color:rgba(0, 0, 0, 0.9);">每个进程有两个优先级（动态优先级和实时优先级），实时优先级就是用来衡量实时进程是否值得运行的。 非实时进程有两种优先级，一种是静态优先级，另一种是动态优先级。实时进程又增加了第三种优先级，实时优先级。优先级越高，得到CPU时间的机会也就越大。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">15</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">：标准库函数和系统调用的区别？</font></u>**<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">系统调用：是操作系统为用户态运行的进程和硬件设备(如CPU、磁盘、打印机等)进行交互提供的一组接口，即就是设置在应用程序和硬件设备之间的一个接口层。inux内核是单内核，结构紧凑，执行速度快，各个模块之间是直接调用的关系。linux系统上到下依次是用户进程->linux内核->硬件。其中系统调用接口是位于Linux内核中的，整个linux系统从上到下可以是：用户进程->系统调用接口->linux内核子系统->硬件，也就是说Linux内核包括了系统调用接口和内核子系统两部分；或者从下到上可以是：物理硬件->OS内核->OS服务->应用程序，操作系统起到“承上启下”作用，向下管理物理硬件，向上为操作系服务和应用程序提供接口，这里的接口就是系统调用了。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">库函数：把函数放到库里。是把一些常用到的函数编完放到一个lib文件里，供别人用。别人用的时候把它所在的文件名用#include<>加到里面就可以了。一类是c语言标准规定的库函数，一类是编译器特定的库函数。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">16</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">：系统如何将一个信号通知到进程？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">内核给进程发送信号，是在进程所在的进程表项的信号域设置对应的信号的位。进程处理信号的时机就是从内核态即将返回用户态度的时候。执行用户自定义的信号处理函数的方法很巧妙。把该函数的地址放在用户栈栈顶，进程从内核返回到用户态的时候，先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">17：fork()</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">一子进程程后</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">父进程的全局变量能不能使用？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">fork后子进程将会拥有父进程的几乎一切资源，父子进程的都各自有自己的全局变量。不能通用，不同于线程。对于线程，各个线程共享全局变量。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">18：请画出socket通信连接过程（</font></u>****<u><font style="color:rgb(77, 77, 77);">三次握手）</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);"> </font></u>**

![](/images/d6e16fac39d931b3cbcf6c9fb3b88a18.png)

**<u><font style="color:rgba(0, 0, 0, 0.9);">19：请用socket消息队列实现“同步非阻塞”和“异步阻塞”两种模式，并指出两者的差别和优劣</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">Socket 和消息队列实现“同步非阻塞”和“异步阻塞”两种模式，需要理解这两种模式的核心区别：</font>

1. **<font style="color:rgba(0, 0, 0, 0.9);">同步非阻塞</font>****<font style="color:rgba(0, 0, 0, 0.9);">：</font>**
    - <font style="color:rgba(0, 0, 0, 0.9);">调用者发起请求后，立即返回，不会阻塞等待结果。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">调用者需要轮询或通过其他方式检查操作是否完成。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">适合需要同时处理多个任务的场景。</font>
2. **<font style="color:rgba(0, 0, 0, 0.9);">异步阻塞</font>****<font style="color:rgba(0, 0, 0, 0.9);">：</font>**
    - <font style="color:rgba(0, 0, 0, 0.9);">调用者发起请求后，立即返回，但会在某个时刻阻塞等待结果。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">通常通过回调函数或事件通知机制获取结果。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">适合需要高效处理 I/O 操作的场景。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">四：网络编程</font>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">1：TCP</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">头大小，包含字段？三次握手，四次断开描述过程，都有些什么状态。状态变迁图。</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">TCP/IP</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">收发缓冲区（</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">2</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">次）</font></u>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">2：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">使用</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">udp</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">和</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">tcp</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">进程网络传输，为什么</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">tcp</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">能保证包是发送顺序，而</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);"> udp</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">无法保证？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">因为TCP发送的数据包是按序号发送，有确认机制和丢失重传机制，而udp是不可靠的发送机制，发送的对应端口的数据包不是按顺序发送的。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">3：epoll</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">哪些触发模式，有啥区别？（必须非常详尽的解释水平触发和边缘触发的区别，以及边缘触发在编程中要做哪些更多的确认）</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值。</font>

<font style="color:rgba(0, 0, 0, 0.9);">也就是说在LT模式的情况下一定要确认收发的数据包的buffer是不是足够大如果收发数据包大小大于buffer的大小的时候就可能会出现数据丢失的情况。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">4：tcp</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">与</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">udp</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的区别（必问）</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">为什么</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">TCP</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">要叫做数据流？</font></u>**

+ <font style="color:rgba(0, 0, 0, 0.9);">1)基于连接与无连接</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2)对系统资源的要求（TCP较多，UDP少）</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">3)UDP程序结构较简单</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">4)流模式与数据报模式</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">5)TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">6)TCP有拥塞控制和流量控制，UDP没有</font>

<font style="color:rgba(0, 0, 0, 0.9);">TCP提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</font>

<font style="color:rgba(0, 0, 0, 0.9);">是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">5</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">：流量控制和拥塞控制的实现机制</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">网络拥塞现象是指到达通信子网中某一部分的分组数量过多,使得该部分网络来不及处理,以致引起这部分乃至整个网络性能下降的现象,严重时甚至会导致网络通信业务陷入停顿,即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">6：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">滑动窗口的实现机制</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">滑动窗口机制，窗口的大小并不是固定的而是根据我们之间的链路的带宽的大小，这个时候链路是否拥护塞。接受方是否能处理这么多数据了。  滑动窗口协议，是TCP使用的一种流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。 </font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">7：epoll</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">和</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">select</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的区别？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1）select在一个进程中打开的最大fd是有限制的，由FD_SETSIZE设置，默认值是2048。不过 epoll则没有这个限制，内存越大，fd上限越大，1G内存都能达到大约10w左右。</font>

<font style="color:rgba(0, 0, 0, 0.9);">2）select的轮询机制是系统会去查找每个fd是否数据已准备好，当fd很多的时候，效率当然就直线下降了，epoll采用基于事件的通知方式，一旦某个fd数据就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，高效。 </font>

<font style="color:rgba(0, 0, 0, 0.9);">3）select还是epoll都需要内核把FD消息通知给用户空间，epoll是通过内核于用户空间mmap同一块内存实现的，而select则做了不必要的拷贝</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">8：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">网络中，如果客户端突然掉线或者重启，服务器端怎么样才能立刻知道？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">若客户端掉线或者重新启动，服务器端会收到复位信号，每一种tcp/ip得实现不一样，控制机制也不一样。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">9：TTL</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">是什么？有什么用处，通常那些工具会用到它？</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">ping? traceroute? ifconfig? netstat?</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">TTL是Time To Live，每经过一个路由就会被减去一，如果它变成0，包会被丢掉。它的主要目的是防止包在有回路的网络上死转，浪费网络资源。ping和traceroute用到它。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">10：linux</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的五种</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">IO</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">模式</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">/</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">异步模式</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">.</font></u>**

+ <font style="color:rgba(0, 0, 0, 0.9);">1）同步阻塞I/O</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2）同步非阻塞I/O</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">3）同步I/O复用模型</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">4） 同步信号驱动I/O</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">5） 异步I/O模型 </font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">11：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">请说出</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">http</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">协议的优缺点</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">.</font></u>**

+ <font style="color:rgba(0, 0, 0, 0.9);">1.支持客户/服务器模式。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径，通信速度很快。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">3.灵活：HTTP允许传输任意类型的数据对象。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，导致每次连接传送的数据量增大。缺点就是不够安全，可以使用https完成使用</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">12：NAT</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">类型，</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">UDP</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">穿透原理。</font></u>**

+ <font style="color:rgba(0, 0, 0, 0.9);">1)</font>**<font style="color:rgba(0, 0, 0, 0.9);">Full cone NAT </font>****<font style="color:rgba(0, 0, 0, 0.9);">（全克隆</font>****<font style="color:rgba(0, 0, 0, 0.9);">nat</font>****<font style="color:rgba(0, 0, 0, 0.9);">）</font>****<font style="color:rgba(0, 0, 0, 0.9);">:</font>**<font style="color:rgba(0, 0, 0, 0.9);">一对一NAT一旦一个内部地址（iAddr:port1）映射到外部地址（eAddr:port2）。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2)</font>**<font style="color:rgba(0, 0, 0, 0.9);">Address-Restricted cone NAT</font>****<font style="color:rgba(0, 0, 0, 0.9);">（地址受限克隆</font>****<font style="color:rgba(0, 0, 0, 0.9);">nat</font>****<font style="color:rgba(0, 0, 0, 0.9);">）</font>****<font style="color:rgba(0, 0, 0, 0.9);">:</font>**<font style="color:rgba(0, 0, 0, 0.9);">任意外部主机（hostAddr:any）都能通过给eAddr:port2发包到达iAddr:port1的前提是：iAddr:port1之前发送过包到hostAddr:any. "any"也就是说端口不受限制</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">3)Port-Restricted cone NAT:</font><font style="color:rgba(0, 0, 0, 0.9);">内部地址（iAddr:port1）映射到外部地址（eAddr:port2），所有发自iAddr:port1的包都经eAddr:port2向外发送。一个外部主机（hostAddr:port3）能够发包到达iAddr:port1的前提是：iAddr:port1之前发送过包到hostAddr:port3.</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);">4)Symmetric NAT</font>****<font style="color:rgba(0, 0, 0, 0.9);">（对称</font>****<font style="color:rgba(0, 0, 0, 0.9);">NAT</font>****<font style="color:rgba(0, 0, 0, 0.9);">）</font>****<font style="color:rgba(0, 0, 0, 0.9);">:</font>**<font style="color:rgba(0, 0, 0, 0.9);">同内部IP与port的请求到一个特定目的地的IP地址和端口，映射到一个独特的外部来源的IP地址和端口。同一个内部主机发出一个信息包到不同的目的端，不同的映射使用外部主机收到了一封包从一个内部主机可以送一封包回来。 </font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">13：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">大规模连接上来，并发模型怎么设计</font></u>**

**<font style="color:rgba(0, 0, 0, 0.9);">Epoll+</font>****<font style="color:rgba(0, 0, 0, 0.9);">线程池（</font>****<font style="color:rgba(0, 0, 0, 0.9);">epoll</font>****<font style="color:rgba(0, 0, 0, 0.9);">可以采用</font>****<font style="color:rgba(0, 0, 0, 0.9);">libevent</font>****<font style="color:rgba(0, 0, 0, 0.9);">处理）</font>**

14：tcp三次握手的，accept发生在三次握手哪个阶段？

<font style="color:rgb(64, 64, 64);">在TCP的三次握手过程中，</font>`<font style="color:rgb(64, 64, 64);">accept</font>`<font style="color:rgb(64, 64, 64);">发生在握手完成之后。具体阶段如下：</font>

1. **<font style="color:rgb(64, 64, 64);">第一次握手</font>**<font style="color:rgb(64, 64, 64);">：客户端发送SYN报文给服务器，请求建立连接。</font>
2. **<font style="color:rgb(64, 64, 64);">第二次握手</font>**<font style="color:rgb(64, 64, 64);">：服务器回复SYN-ACK报文，表示同意建立连接。</font>
3. **<font style="color:rgb(64, 64, 64);">第三次握手</font>**<font style="color:rgb(64, 64, 64);">：客户端发送ACK报文，确认连接建立。</font>
4. <font style="color:rgb(64, 64, 64);">accept是服务器在完成三次握手后，从已完成连接队列中取出一个已建立的连接，返回一个新的套接字用于与客户端通信。因此，accept发生在三次握手完成之后。</font>

15：流量控制与拥塞控制的区别，节点计算机怎样感知网络拥塞了？

<font style="color:rgba(0, 0, 0, 0.9);">拥塞控制是把整体看成一个处理对象的，流量控制是对单个的节点。</font>

<font style="color:rgba(0, 0, 0, 0.9);">感知的手段应该不少，比如在TCP协议里，TCP报文的重传本身就可以作为拥塞的依据。依据这样的原理， 应该可以设计出很多手段。 </font>

**<font style="color:rgba(0, 0, 0, 0.9);">五：算法和数据结构</font>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">1：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">给定一个单向链表（长度未知），请设计一个既节省时间又节省空间的算法来找出该链表中的倒数第</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">m</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">个元素。实现这个算法，并为可能出现的特例情况安排好处理措施。“倒数第</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">m</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">个元素”是这样规定的：当</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">m=0</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">时，链表的最后一个元素将被返回。</font></u>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">解决问题方法思路如下：</font></u>**

**<font style="color:rgba(0, 0, 0, 0.9);">方法一、</font>**<font style="color:rgba(0, 0, 0, 0.9);">如果我们知道链表的长度n，查找倒数第m个元素，也就是查找正序的第（n -  m）个元素（这里的序号只是为了分析，可能跟题目不一定正确的符合）。那么这样来说就简单很多。首先遍历链表得到链表长度，然后重新遍历一次，查找正数第（n-m）个元素。时间复杂度大约是O(2n)。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">方法二、</font>**<font style="color:rgba(0, 0, 0, 0.9);">我们是不是可以提供一个辅助存储空间，是的我们在遍历到链表结束的时候可以回溯到倒数第m个元素。比如用一个支持随机访问的容器记录链表每一个节点的地址。那么这样的就可以只遍历一次链表就能得到结果。时间复杂度大约是O(n)，但是我们是用空间换取时间的，辅助存储空间的大小由m决定，如果m过大也是不可取的。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">方法三、</font>**<font style="color:rgba(0, 0, 0, 0.9);">头结点指针为当前指针，尾节点指针为拖后指针。开始的时候当前指针和拖后指针初始化为链表的头结点，首先我们让当前指针遍历到第m个元素，拖后指针不变；然后同步更新当前指针和拖后指针；直到当前指针为链表结尾。这样我们就能保证当前指针和拖尾指针之间的距离是m。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">代码如下：</font>**

```plain
Node* FindMToLastNode(Node* pHead, int m)  {  
    // 查找到第m个元素  
    Node* pCurrent = pHead;  
    for (int i = 0; i < m; ++i)  
    {  
        if (pCurrent)  
        {  
            pCurrent = pCurrent->next;  
        }  
        else  
        {  
            return NULL;  
        }  
    }  
  
    Node* pFind = pHead;  
    while (pCurrent)   {  
        pFind        = pFind->next;  
        pCurrent    = pCurrent->next;  
    }   
    return pFind;  
}
```

**<u><font style="color:rgb(51, 51, 51);">2：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">给定一个单向链表（长度未知），请遍历一次就找到中间的指针，假设该链表存储在只读存储器，不能被修改</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">设置两个指针，一个每次移动两个位置，一个每次移动一个位置，当第一个指针到达尾节点时，第二个指针就达到了中间节点的位置</font>

<font style="color:rgba(0, 0, 0, 0.9);">处理链表问题时，”快行指针“是一种很常见的技巧，快行指针指的是同时用两个指针来迭代访问链表，只不过其中一个比另一个超前一些。快指针往往先行几步，或与慢指针相差固定的步数。</font>

```plain
node *create()  {  
    node *p1, *p2, *head;  
    int cycle = 1, x;  
    head = (node*)malloc(sizeof(node));  
    p1 = head;  
    while (cycle)  
    {         
        cout << "please input an integer: ";  
        cin >> x;  
        if (x != 0)  
        {  
            p2 = (node*)malloc(sizeof(node));  
            p2->data = x;  
            p1->next = p2;  
            p1 = p2;  
        }  
  
        else  
        {  
            cycle = 0;  
        }  
    }  
    head = head->next;  
    p1->next = NULL;  
    return head;  
}  
void findmid(node* head)  {  
    node *p1, *p2, *mid;  
    p1 = head;  
    p2 = head;  
  
    while (p1->next->next != NULL)  
    {     
        p1 = p1->next->next;  
        p2 = p2->next;  
        mid = p2;  
    }     
}
```

**<u><font style="color:rgba(0, 0, 0, 0.9);">3：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">将一个数组生成二叉排序树</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">排序，选数组中间的一个元素作为根节点，左边的元素构造左子树，右边的节点构造有子树。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">4：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">查找数组中第</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">k</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">大的数字？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">因为快排每次将数组划分为两组加一个枢纽元素，每一趟划分你只需要将k与枢纽元素的下标进行比较，如果比枢纽元素下标大就从右边的子数组中找，如果比枢纽元素下标小从左边的子数组中找，如果一样则就是枢纽元素，找到，如果需要从左边或者右边的子数组中再查找的话，只需要递归一边查找即可，无需像快排一样两边都需要递归，所以复杂度必然降低。</font>

<font style="color:rgba(0, 0, 0, 0.9);">最差情况如下：假设快排每次都平均划分，但是都不在枢纽元素上找到第k大第一趟快排没找到，时间复杂度为O(n)，第二趟也没找到，时间复杂度为O(n/2)，第k趟找到，时间复杂度为O(n/2k)，所以总的时间复杂度为O(n(1+1/2+....+1/2k))=O(n)，明显比冒泡快，虽然递归深度是一样的，但是每一趟时间复杂度降低。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">5：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">红黑树的定义和解释？</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">B</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">树的基本性质？</font></u>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">红黑树：</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">性质1. 节点是红色或黑色。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">性质2. 根节点是黑色。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">性质3. 每个叶子结点都带有两个空的黑色结点（被称为黑哨兵），如果一个结点n的只有一个左孩子，那么n的右孩子是一个黑哨兵；如果结点n只有一个右孩子，那么n的左孩子是一个黑哨兵。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">B树：</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">1.所有非叶子结点至多拥有两个儿子（Left和Right）；</font>

<font style="color:rgba(0, 0, 0, 0.9);">2.所有结点存储一个关键字；</font>

<font style="color:rgba(0, 0, 0, 0.9);">3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树； </font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">6：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">常见的加密算法？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">对称式加密就是加密和解密使用同一个密钥。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">非对称式加密就是加密和解密所使用的不是同一个密钥，通常有两个密钥，称为“公钥”和“私钥”，它们两个必需配对使用。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">DES：对称算法，数据加密标准，速度较快，适用于加密大量数据的场合；</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">MD5的典型应用是对一段Message产生fingerprint(指纹)，以防止被“篡改”。</font><font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">RSA是第一个既能用于数据加密也能用于数字签名的算法。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">7：https?</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">HTTP下加入SSL层，HTTPS的安全基础是SSL。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">8：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">有一个</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">IP</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">库，给你一个</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">IP,</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">如何能够快速的从中查找到对应的</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">IP</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">段？</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">不用数据库如何实现？要求省空间</font></u>****<font style="color:rgb(51, 51, 51);">  
</font>****<u><font style="color:rgba(0, 0, 0, 0.9);">9：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">简述一致性</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">hash</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">算法。</font></u>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">1）首先求memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）。</font></u>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">2）然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</font></u>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">3）然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台memcached服务器上。</font></u>****<font style="color:rgb(51, 51, 51);">  
</font>****<u><font style="color:rgba(0, 0, 0, 0.9);">10：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">描述一种</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">hash table</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的实现方法</font></u>**

+ <font style="color:rgba(0, 0, 0, 0.9);">1） 除法散列法: p ，令 h(k ) = k mod p ，这里， p 如果选取的是比较大的素数，效果比较好。而且此法非常容易实现，因此是最常用的方法。最直观的一种，上图使用的就是这种散列法，公式： index = value % 16，求模数其实是通过一个除法运算得到的。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">2） 平方散列法 :求index频繁的操作，而乘法的运算要比除法来得省时。公式： index = (value * value) >> 28 （右移，除以2^28。记法：左移变大，是乘。右移变小，是除）</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">3） 数字选择法:如果关键字的位数比较多，超过长整型范围而无法直接运算，可以选择其中数字分布比较均匀的若干位，所组成的新的值作为关键字或者直接作为函数值。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">4） 斐波那契（Fibonacci）散列法:平方散列法的缺点是显而易见的，通过找到一个理想的乘数index = (value * 2654435769) >> 28</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">冲突处理：令数组元素个数为 S ，则当 h(k) 已经存储了元素的时候，依次探查 (h(k)+i) mod S , i=1,2,3…… ，直到找到空的存储单元为止（或者从头到尾扫描一圈仍未发现空单元，这就是哈希表已经满了，发生了错误。当然这是可以通过扩大数组范围避免的）。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">11：各类树结构的实现和应用</font></u>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">12：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">hash</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">，</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">任何一个技术面试官必问（例如为什么一般</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">hashtable</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的桶数会取一个素数？如何有效避免</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">hash</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">结果值的碰撞）</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">不选素数的话可能会造成hash出值的范围和原定义的不一致</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">13：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">什么是平衡二叉树</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">?</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">左右子树都是平衡二叉树，而且左右子树的深度差值的约对值不大于1。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">14：数组和链表的优缺点</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">数组，在内存上给出了连续的空间。链表，内存地址上可以是不连续的，每个链表的节点包括原来的内存和下一个节点的信息(单向的一个，双向链表的话，会有两个)。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">数组优于链表的:</font>**

<font style="color:rgba(0, 0, 0, 0.9);">A. 内存空间占用的少。</font>

<font style="color:rgba(0, 0, 0, 0.9);">B. 数组内的数据可随机访问，但链表不具备随机访问性。</font>

<font style="color:rgba(0, 0, 0, 0.9);">C. 查找速度快</font>

**<font style="color:rgba(0, 0, 0, 0.9);">链表优于数组的:</font>**

<font style="color:rgba(0, 0, 0, 0.9);">A. 插入与删除的操作方便。</font>

<font style="color:rgba(0, 0, 0, 0.9);">B. 内存地址的利用率方面链表好。</font>

<font style="color:rgba(0, 0, 0, 0.9);">C. 方便内存地址扩展。</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">15：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">最小堆</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">插入，删除</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">编程实现</font></u>**

**<u><font style="color:rgba(0, 0, 0, 0.9);">16：4G</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">的long</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">型整数中找到一个最大的，如何做？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">每次从磁盘上尽量多读一些数到内存区，然后处理完之后再读入一批。减少IO次数，自然能够提高效率。分批读入选取最大数，再对缓存的最大数进行快排。 </font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">17：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">有千万个</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">string</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">在内存怎么高速查找，插入和删除？</font></u>**

<font style="color:rgba(0, 0, 0, 0.9);">对千万个string做hash，可以实现高速查找，找到了，插入和删除就很方便了。关键是如何做hash，对string做hash，要减少碰撞频率。</font>

18：100亿个数，求最大的1万个数，并说出算法的时间复杂度

<font style="color:rgba(0, 0, 0, 0.9);">在内存中维护一个大小为10000的最小堆，每次从文件读一个数，与最小堆的堆顶元素比较，若比堆顶元素大，则替换掉堆顶元素，然后调整堆。最后剩下的堆内元素即为最大的1万个数，算法复杂度为O(NlogN)</font>

19：设计一个洗牌的算法，并说出算法的时间复杂度。

<font style="color:rgba(0, 0, 0, 0.9);">（1）全局洗牌法</font>

<font style="color:rgba(0, 0, 0, 0.9);">a）首先生成一个数组，大小为54，初始化为1~54</font>

<font style="color:rgba(0, 0, 0, 0.9);">b）按照索引1到54，逐步对每一张索引牌进行洗牌，首先生成一个余数 value = rand %54，那么我们的索引牌就和这个余数牌进行交换处理</font>

<font style="color:rgba(0, 0, 0, 0.9);">c）等多索引到54结束后，一副牌就洗好了</font>

<font style="color:rgba(0, 0, 0, 0.9);">（2）局部洗牌法：索引牌从1开始，到54结束。这一次索引牌只和剩下还没有洗的牌进行交换， value = index + rand（） %（54 - index）</font>

<font style="color:rgba(0, 0, 0, 0.9);">算法复杂度是O(n)</font>

**<u><font style="color:rgba(0, 0, 0, 0.9);">20：</font></u>****<u><font style="color:rgba(0, 0, 0, 0.9);">请分别用递归和非递归方法，先序遍历二叉树</font></u>**

### **<font style="color:rgb(64, 64, 64);">递归方法</font>**
<font style="color:rgb(64, 64, 64);">递归方法直接按照先序遍历的顺序（根 -> 左 -> 右）实现。</font>

```plain
#include <iostream>
#include <vector>


using namespace std;


// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// 递归先序遍历
void preorderRecursive(TreeNode* root, vector<int>& result) {
    if (!root) return; // 如果节点为空，直接返回
    result.push_back(root->val); // 访问根节点
    preorderRecursive(root->left, result); // 递归遍历左子树
    preorderRecursive(root->right, result); // 递归遍历右子树
}


// 调用递归方法
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> result;
    preorderRecursive(root, result);
    return result;
}
```

### **<font style="color:rgb(64, 64, 64);">非递归方法</font>**
<font style="color:rgb(64, 64, 64);">非递归方法使用栈来模拟递归过程。</font>

```plain
#include <iostream>
#include <vector>
#include <stack>


using namespace std;


// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


// 非递归先序遍历
vector<int> preorderIterative(TreeNode* root) {
    vector<int> result;
    if (!root) return result; // 如果根节点为空，直接返回


    stack<TreeNode*> stack;
    stack.push(root); // 将根节点压入栈


    while (!stack.empty()) {
        TreeNode* node = stack.top(); // 取出栈顶节点
        stack.pop();
        result.push_back(node->val); // 访问根节点


        // 先将右子树压入栈，再将左子树压入栈（因为栈是后进先出）
        if (node->right) stack.push(node->right);
        if (node->left) stack.push(node->left);
    }


    return result;
}
```

### <font style="color:rgb(64, 64, 64);">测试代码</font>
```plain
int main() {
    // 构建一个简单的二叉树
    //     1
    //    / \
    //   2   3
    //  / \
    // 4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);


    // 递归先序遍历
    cout << "Recursive Preorder: ";
    vector<int> recursiveResult = preorderTraversal(root);
    for (int val : recursiveResult) {
        cout << val << " ";
    }
    cout << endl;


    // 非递归先序遍历
    cout << "Iterative Preorder: ";
    vector<int> iterativeResult = preorderIterative(root);
    for (int val : iterativeResult) {
        cout << val << " ";
    }
    cout << endl;


    return 0;
}
```

### <font style="color:rgb(64, 64, 64);">输出结果</font>
```plain
Recursive Preorder: 1 2 4 5 3 
Iterative Preorder: 1 2 4 5 3
```

### <font style="color:rgb(64, 64, 64);">总结</font>
+ **<font style="color:rgb(64, 64, 64);">递归方法</font>**<font style="color:rgb(64, 64, 64);">：代码简洁，易于理解，但可能会因为递归深度过大导致栈溢出。</font>
+ **<font style="color:rgb(64, 64, 64);">非递归方法</font>**<font style="color:rgb(64, 64, 64);">：使用栈模拟递归，避免了栈溢出的问题，适合深度较大的树。</font>

  


> 来自: [面试官爱问，命中率最高，100道C++面试题，全面总结分析](https://mp.weixin.qq.com/s/LgF5nBgvUA3YpvtLbpB9Sw)
>

