---
title: "\U0001F34E06-C++面试之STL内存管理篇_牛客网"
date: '2025-01-10 02:15:01'
updated: '2025-01-10 02:15:02'
---
[toc]

## 0 前述
本部分关于`CPP`的`STL`的内存管理方式的点来展开即可，分别讨论普通的内存管理方式和`STL`的内存管理方式，以及`STL`内存管理方式本身的可改善的点。

## 1 普通的内存管理方式
我们知道动态开辟内存是，要在堆上申请；

1）如果说需要的频繁的话，就需要一次次在堆上开辟和释放内存，并且会造成内存碎片化，浪费内存空间（在申请一整个大块内存空间的时候，都是不连续的小碎片）；

2）且每次申请都要进行调用`malloc`和`free`操作，造成配置时的一些额外负担。

以此，以效率著称的`STL`库，提出两级空间配置器。1）当一次申请的内存够大，超过`128bytes`时，就移交给第一级配置器处理，就是直接`new`和`delete`出一块大内存；2）当一次申请的空间小于`128bytes`，就使用二级配置器以**内存池**的形式进行管理。内存池的一个显著优点就是尽量避免内存碎片，使得内存分配效率得到提升。

## 2 `STL`内存管理方式
+ 整体形式，维护`16`条`free-list`，对应各大小的内存块，从`0~15`号，内存最小`8bytes`，以`8bytes`逐渐递增，最大`128bytes`。传入的参数会自动将内存需求量上调至`8`的倍数（比如客户端需要`30bytes`，这边就自动商调至`32bytes`），找到`32bytes`所对应的内存大小的链表；
+ 查看是否为空，不为空的话就直接从该链表中取出一个分配给该请求，再将对应链表的指针向后移动一位。
+ 若对应的链表为空的话，进一步，先看看内存池是不是空的，不空，就从内存池里面分配

1）先检查内存池剩余空间，够不够`20`个（默认）这样的（`32bytes`大小）的空间，若足够就直接拿出，将一个分配出去，剩下的挂载对应的`free-list`下，等待下次分配。

2）如果不够`20`个大小，看够不够1个，够1个就先直接分配出去。再更新`free-list`,将内存池剩余的空间分配尽可能多的节点挂在其他`free-list`上面。

3）若果池子剩余的空间一个都满足不了的话，先将内存池中剩余的空间挂在相应小内存的`free-list`上，然后，找老大"系统"😎给内存池分配空间。

+ 内存池空的话

1）给内存池申请内存，使用`malloc()`从`heap`上申请内存（一次申请的内存大小为= 2*所需节点内存（8的倍数） * 20个 + 一段额外的空间），大约申请40块，一半拿来用，放在`free-list`上面；一般放在内存池中。

	😯一个奇怪的提问：为什么会是乘以2的操作，就和`vector`，在存放满的时候，进行扩充一样，为什么是2倍，不是1.5倍这样的扩充：（曾经有个面试官这样问过）

答：目前看来大致是，2对于计算机来说比较好处理一些，二进制直接使用`10`即可表示出来。

2）假若系统中没有`malloc`出来，说明`heap`（系统）上也没有内存了，那就从其他大的`free-list`上借一个节点使用。如果系统上也没有找到，那就只能调用一级配置器。

## 3 `STL`的一些缺点
+ 自由链表的管理问题，把所需要申请的内存自动调整到8的倍数。比如，你需要申请1个字节的话，也就给你8bytes，浪费，久而久之，也会造成内部碎片的问题。
+ 内存的使用过程中，所申请的内存会一块块挂在free-list上面，也不会还给操作系统，申请的内存只有在当前进程结束的时候，才会释放内存。

1）开辟小内存开辟的太多，导致申请大内存的时候，就容易失败；

2）申请的内存太多，不归还，别的进程想用但是没有，会引发问题。

  


> 来自: [🍎06-C++面试之STL内存管理篇_牛客网](https://www.nowcoder.com/discuss/532593976755466240?sourceSSR=users)
>

